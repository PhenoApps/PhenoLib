/**
 * BrAPI
 * The Breeding API (BrAPI) is a Standardized RESTful Web Service API Specification for communicating Plant Breeding Data. BrAPI allows for easy data sharing between databases and tools involved in plant breeding.  <strong>General Reference Documentation</strong> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/URL_Structure.md\">URL Structure</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Response_Structure.md\">Response Structure</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Date_Time_Encoding.md\">Date/Time Encoding</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Location_Encoding.md\">Location Encoding</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Error_Handling.md\">Error Handling</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Search_Services.md\">Search Services</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Asychronous_Processing.md\">Asynchronous Processing</a>
 *
 * OpenAPI spec version: 1.2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api;

import io.swagger.client.ApiInvoker;
import io.swagger.client.ApiException;
import io.swagger.client.Pair;

import io.swagger.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import java.util.Date;
import io.swagger.client.model.NewObservationDbIdsResponse;
import io.swagger.client.model.ObservationUnitsResponse;
import io.swagger.client.model.ObservationUnitsTableResponse1;
import io.swagger.client.model.PhenotypesRequest;
import io.swagger.client.model.PhenotypesSearchRequest;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class PhenotypesApi {
  String basePath = "https://test-server.brapi.org/brapi/v1";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Save Observation Unit Phenotypes
  * Scope: PHENOTYPING.   Notes:  Along with the study specific phenotype saving calls (in the observationUnit and table formats), this call allows phenotypes to be saved and images to optionally be transferred as well.        Call to invoke for saving the measurements (observations) collected from field for all the observation units. Observation timestamp should be ISO 8601 https://www.w3.org/TR/NOTE-datetime In case where JSON data is zipped for faster transfer speed (as in the case of the IRRI handheld implementation), the zipped JSON file will be listed in datafiles. The zipped file contains a JSON file with the same structure as the BrAPI call. In this case a format parameter should be passed as well. Images can be optionally be uploaded using this call by providing a zipfile of all images in the datafiles, along with the actual zipfile in multi-part form data.
   * @param format In case where JSON data is zipped for faster transfer speed (as in the case of the IRRI handheld implementation), the zipped JSON file will be listed in datafiles. The zipped file contains a JSON file with the same structure as the BrAPI call.
   * @param body 
   * @return NewObservationDbIdsResponse
  */
  public NewObservationDbIdsResponse phenotypesPost (String format, PhenotypesRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;

    // create path and map variables
    String path = "/phenotypes";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NewObservationDbIdsResponse) ApiInvoker.deserialize(localVarResponse, "", NewObservationDbIdsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Save Observation Unit Phenotypes
   * Scope: PHENOTYPING.   Notes:  Along with the study specific phenotype saving calls (in the observationUnit and table formats), this call allows phenotypes to be saved and images to optionally be transferred as well.        Call to invoke for saving the measurements (observations) collected from field for all the observation units. Observation timestamp should be ISO 8601 https://www.w3.org/TR/NOTE-datetime In case where JSON data is zipped for faster transfer speed (as in the case of the IRRI handheld implementation), the zipped JSON file will be listed in datafiles. The zipped file contains a JSON file with the same structure as the BrAPI call. In this case a format parameter should be passed as well. Images can be optionally be uploaded using this call by providing a zipfile of all images in the datafiles, along with the actual zipfile in multi-part form data.
   * @param format In case where JSON data is zipped for faster transfer speed (as in the case of the IRRI handheld implementation), the zipped JSON file will be listed in datafiles. The zipped file contains a JSON file with the same structure as the BrAPI call.   * @param body 
  */
  public void phenotypesPost (String format, PhenotypesRequest body, final Response.Listener<NewObservationDbIdsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;


    // create path and map variables
    String path = "/phenotypes".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NewObservationDbIdsResponse) ApiInvoker.deserialize(localVarResponse,  "", NewObservationDbIdsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Phenotype Search CSV
  * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.        observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
   * @return String
  */
  public String phenotypesSearchCsvPost (PhenotypesSearchRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;

    // create path and map variables
    String path = "/phenotypes-search/csv";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (String) ApiInvoker.deserialize(localVarResponse, "", String.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Phenotype Search CSV
   * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.        observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
  */
  public void phenotypesSearchCsvPost (PhenotypesSearchRequest body, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;


    // create path and map variables
    String path = "/phenotypes-search/csv".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((String) ApiInvoker.deserialize(localVarResponse,  "", String.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Phenotype Search
  * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  Implemented for GnpIS and PHIS data (https://urgi.versailles.inra.fr/ws/webresources/brapi/v1/phenotypes).  Use case: this section allows to get a dataset from multiple studies. It allows to integrate data from several databases. Refactor note : This call allows to get and integrate portions of multiple phenotyping data matrixes. A proposed evolution allowed to get a list of single observations, this functionality is still possible with this call by specifybing the observation variable, see below. Example Use cases: - Study a panel of germplasm accross multiple studies, search parameters : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ]} - Get all data for a specific study : {\&quot;studyDbIds\&quot; : [ \&quot;383\&quot; ]} - Get simple atomic phenotyping values : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ], \&quot;observationVariableDbIds\&quot; : [ \&quot;CO_345:0000043\&quot;]} - Study Locations for adaptation to climat change : {\&quot;locationDbIds\&quot; : [ \&quot;383838\&quot;, \&quot;MONTPELLIER\&quot; ], \&quot;germplasmDbIds\&quot; : [ \&quot;all ids for a given species\&quot;]} - Find phenotypes that are from after a certain timestamp  observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param germplasmDbId The name or synonym of external genebank accession identifiers
   * @param observationVariableDbId The ID of traits, could be ontology ID, database ID or PUI
   * @param studyDbId The database ID / PK of the studies search parameter
   * @param locationDbId locations these traits were collected
   * @param trialDbId trial to search across
   * @param programDbId program that have phenotyped this trait
   * @param seasonDbId The year or Phenotyping campaign of a multi-annual study (trees, grape, ...)
   * @param observationLevel The type of the observationUnit. Returns only the observation unit of the specified type; the parent levels ID can be accessed through observationUnitStructure.
   * @param observationTimeStampRangeStart Timestamp range start
   * @param observationTimeStampRangeEnd Timestamp range end
   * @param pageSize The size of the pages to be returned. Default is 1000.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is 0.
   * @return ObservationUnitsResponse
  */
  public ObservationUnitsResponse phenotypesSearchGet (String germplasmDbId, String observationVariableDbId, String studyDbId, String locationDbId, String trialDbId, String programDbId, String seasonDbId, String observationLevel, Date observationTimeStampRangeStart, Date observationTimeStampRangeEnd, Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/phenotypes-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "germplasmDbId", germplasmDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationVariableDbId", observationVariableDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "studyDbId", studyDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationDbId", locationDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "trialDbId", trialDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "programDbId", programDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "seasonDbId", seasonDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationLevel", observationLevel));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationTimeStampRangeStart", observationTimeStampRangeStart));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationTimeStampRangeEnd", observationTimeStampRangeEnd));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObservationUnitsResponse) ApiInvoker.deserialize(localVarResponse, "", ObservationUnitsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Phenotype Search
   * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  Implemented for GnpIS and PHIS data (https://urgi.versailles.inra.fr/ws/webresources/brapi/v1/phenotypes).  Use case: this section allows to get a dataset from multiple studies. It allows to integrate data from several databases. Refactor note : This call allows to get and integrate portions of multiple phenotyping data matrixes. A proposed evolution allowed to get a list of single observations, this functionality is still possible with this call by specifybing the observation variable, see below. Example Use cases: - Study a panel of germplasm accross multiple studies, search parameters : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ]} - Get all data for a specific study : {\&quot;studyDbIds\&quot; : [ \&quot;383\&quot; ]} - Get simple atomic phenotyping values : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ], \&quot;observationVariableDbIds\&quot; : [ \&quot;CO_345:0000043\&quot;]} - Study Locations for adaptation to climat change : {\&quot;locationDbIds\&quot; : [ \&quot;383838\&quot;, \&quot;MONTPELLIER\&quot; ], \&quot;germplasmDbIds\&quot; : [ \&quot;all ids for a given species\&quot;]} - Find phenotypes that are from after a certain timestamp  observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param germplasmDbId The name or synonym of external genebank accession identifiers   * @param observationVariableDbId The ID of traits, could be ontology ID, database ID or PUI   * @param studyDbId The database ID / PK of the studies search parameter   * @param locationDbId locations these traits were collected   * @param trialDbId trial to search across   * @param programDbId program that have phenotyped this trait   * @param seasonDbId The year or Phenotyping campaign of a multi-annual study (trees, grape, ...)   * @param observationLevel The type of the observationUnit. Returns only the observation unit of the specified type; the parent levels ID can be accessed through observationUnitStructure.   * @param observationTimeStampRangeStart Timestamp range start   * @param observationTimeStampRangeEnd Timestamp range end   * @param pageSize The size of the pages to be returned. Default is 1000.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is 0.
  */
  public void phenotypesSearchGet (String germplasmDbId, String observationVariableDbId, String studyDbId, String locationDbId, String trialDbId, String programDbId, String seasonDbId, String observationLevel, Date observationTimeStampRangeStart, Date observationTimeStampRangeEnd, Integer pageSize, Integer page, final Response.Listener<ObservationUnitsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/phenotypes-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "germplasmDbId", germplasmDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationVariableDbId", observationVariableDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "studyDbId", studyDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationDbId", locationDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "trialDbId", trialDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "programDbId", programDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "seasonDbId", seasonDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationLevel", observationLevel));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationTimeStampRangeStart", observationTimeStampRangeStart));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationTimeStampRangeEnd", observationTimeStampRangeEnd));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObservationUnitsResponse) ApiInvoker.deserialize(localVarResponse,  "", ObservationUnitsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Phenotype Search
  * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  Implemented for GnpIS and PHIS data (https://urgi.versailles.inra.fr/ws/webresources/brapi/v1/phenotypes).  Use case: this section allows to get a dataset from multiple studies. It allows to integrate data from several databases. Refactor note : This call allows to get and integrate portions of multiple phenotyping data matrixes. A proposed evolution allowed to get a list of single observations, this functionality is still possible with this call by specifybing the observation variable, see below. Example Use cases: - Study a panel of germplasm accross multiple studies, search parameters : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ]} - Get all data for a specific study : {\&quot;studyDbIds\&quot; : [ \&quot;383\&quot; ]} - Get simple atomic phenotyping values : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ], \&quot;observationVariableDbIds\&quot; : [ \&quot;CO_345:0000043\&quot;]} - Study Locations for adaptation to climat change : {\&quot;locationDbIds\&quot; : [ \&quot;383838\&quot;, \&quot;MONTPELLIER\&quot; ], \&quot;germplasmDbIds\&quot; : [ \&quot;all ids for a given species\&quot;]} - Find phenotypes that are from after a certain timestamp  observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
   * @return ObservationUnitsResponse
  */
  public ObservationUnitsResponse phenotypesSearchPost (PhenotypesSearchRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;

    // create path and map variables
    String path = "/phenotypes-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObservationUnitsResponse) ApiInvoker.deserialize(localVarResponse, "", ObservationUnitsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Phenotype Search
   * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  Implemented for GnpIS and PHIS data (https://urgi.versailles.inra.fr/ws/webresources/brapi/v1/phenotypes).  Use case: this section allows to get a dataset from multiple studies. It allows to integrate data from several databases. Refactor note : This call allows to get and integrate portions of multiple phenotyping data matrixes. A proposed evolution allowed to get a list of single observations, this functionality is still possible with this call by specifybing the observation variable, see below. Example Use cases: - Study a panel of germplasm accross multiple studies, search parameters : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ]} - Get all data for a specific study : {\&quot;studyDbIds\&quot; : [ \&quot;383\&quot; ]} - Get simple atomic phenotyping values : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ], \&quot;observationVariableDbIds\&quot; : [ \&quot;CO_345:0000043\&quot;]} - Study Locations for adaptation to climat change : {\&quot;locationDbIds\&quot; : [ \&quot;383838\&quot;, \&quot;MONTPELLIER\&quot; ], \&quot;germplasmDbIds\&quot; : [ \&quot;all ids for a given species\&quot;]} - Find phenotypes that are from after a certain timestamp  observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
  */
  public void phenotypesSearchPost (PhenotypesSearchRequest body, final Response.Listener<ObservationUnitsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;


    // create path and map variables
    String path = "/phenotypes-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObservationUnitsResponse) ApiInvoker.deserialize(localVarResponse,  "", ObservationUnitsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Phenotype Search Table
  * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.        observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
   * @return ObservationUnitsTableResponse1
  */
  public ObservationUnitsTableResponse1 phenotypesSearchTablePost (PhenotypesSearchRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;

    // create path and map variables
    String path = "/phenotypes-search/table";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObservationUnitsTableResponse1) ApiInvoker.deserialize(localVarResponse, "", ObservationUnitsTableResponse1.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Phenotype Search Table
   * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.        observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
  */
  public void phenotypesSearchTablePost (PhenotypesSearchRequest body, final Response.Listener<ObservationUnitsTableResponse1> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;


    // create path and map variables
    String path = "/phenotypes-search/table".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObservationUnitsTableResponse1) ApiInvoker.deserialize(localVarResponse,  "", ObservationUnitsTableResponse1.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Phenotype Search TSV
  * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.        observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
   * @return String
  */
  public String phenotypesSearchTsvPost (PhenotypesSearchRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;

    // create path and map variables
    String path = "/phenotypes-search/tsv";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (String) ApiInvoker.deserialize(localVarResponse, "", String.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Phenotype Search TSV
   * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.        observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
  */
  public void phenotypesSearchTsvPost (PhenotypesSearchRequest body, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;


    // create path and map variables
    String path = "/phenotypes-search/tsv".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((String) ApiInvoker.deserialize(localVarResponse,  "", String.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
