/**
 * BrAPI
 * The Breeding API (BrAPI) is a Standardized RESTful Web Service API Specification for communicating Plant Breeding Data. BrAPI allows for easy data sharing between databases and tools involved in plant breeding.  <strong>General Reference Documentation</strong> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/URL_Structure.md\">URL Structure</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Response_Structure.md\">Response Structure</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Date_Time_Encoding.md\">Date/Time Encoding</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Location_Encoding.md\">Location Encoding</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Error_Handling.md\">Error Handling</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Search_Services.md\">Search Services</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Asychronous_Processing.md\">Asynchronous Processing</a>
 *
 * OpenAPI spec version: 1.2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api;

import io.swagger.client.ApiInvoker;
import io.swagger.client.ApiException;
import io.swagger.client.Pair;

import io.swagger.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import io.swagger.client.model.AlleleMatrixDetailsResponse;
import io.swagger.client.model.AlleleMatrixSearchRequest;
import io.swagger.client.model.AlleleMatrixValuesResponse;
import io.swagger.client.model.MarkerProfileDescriptionsResponse;
import io.swagger.client.model.MarkerProfilesResponse;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class MarkerProfilesApi {
  String basePath = "https://test-server.brapi.org/brapi/v1";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Matrices through GET
  * &lt;strong&gt;Status&lt;/strong&gt;: Proposed &lt;strong&gt;Implemented by&lt;/strong&gt;: GOBII &lt;strong&gt;Used by&lt;/strong&gt;: Flapjack &lt;/br&gt; This resource is used for reading and writing genomic matrices: &lt;/br&gt; GET provides a list of available matrices, optionally filtered by study; POST will provide a means for adding new matrices (content TBD).
   * @param studyDbId restricts the list of matrices to a specific study.
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @return AlleleMatrixDetailsResponse
  */
  public AlleleMatrixDetailsResponse allelematricesGet (String studyDbId, Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling allelematricesGet",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling allelematricesGet"));
    }

    // create path and map variables
    String path = "/allelematrices";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "studyDbId", studyDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AlleleMatrixDetailsResponse) ApiInvoker.deserialize(localVarResponse, "", AlleleMatrixDetailsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Matrices through GET
   * &lt;strong&gt;Status&lt;/strong&gt;: Proposed &lt;strong&gt;Implemented by&lt;/strong&gt;: GOBII &lt;strong&gt;Used by&lt;/strong&gt;: Flapjack &lt;/br&gt; This resource is used for reading and writing genomic matrices: &lt;/br&gt; GET provides a list of available matrices, optionally filtered by study; POST will provide a means for adding new matrices (content TBD).
   * @param studyDbId restricts the list of matrices to a specific study.   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
  */
  public void allelematricesGet (String studyDbId, Integer pageSize, Integer page, final Response.Listener<AlleleMatrixDetailsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling allelematricesGet",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling allelematricesGet"));
    }

    // create path and map variables
    String path = "/allelematrices".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "studyDbId", studyDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AlleleMatrixDetailsResponse) ApiInvoker.deserialize(localVarResponse,  "", AlleleMatrixDetailsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Scores through GET
  * Status: ACCEPTED.  Implemented by: Germinate (POST only), Cassavabase  Used by: Flapjack (POST only)  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  This uses a more efficient data structure and pagination for large number of markers.  See Search Services for additional implementation details. &lt;/br&gt; This uses a more efficient data structure and pagination for large number of markers.  &lt;/br&gt; Use GET when parameter size is less than 2K bytes. This method may support asynchronous processing.
   * @param markerprofileDbId The markerprofile db ids. Not Required if &#39;markerDbId&#39; or &#39;matrixDbId&#39; is present.
   * @param markerDbId ids of the markers. if none are specified, results are returned for all markers in the database. Not Required if &#39;markerprofileDbId&#39; or &#39;matrixDbId&#39; is present.
   * @param matrixDbId 
   * @param format format for the datafile to be downloaded. tsv and csv currently supported; flapjack may be supported.
   * @param expandHomozygotes Should homozygotes NOT be collapsed into a single occurrence?
   * @param unknownString The string to use as a representation for missing data or the reserved word \&quot;empty_string\&quot;.
   * @param sepPhased The string to use as a separator for phased allele calls or the reserved word \&quot;empty_string\&quot;.
   * @param sepUnphased The string to use as a separator for unphased allele calls or the reserved word \&quot;empty_string\&quot;.
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @return AlleleMatrixValuesResponse
  */
  public AlleleMatrixValuesResponse allelematricesSearchGet (List<String> markerprofileDbId, List<String> markerDbId, List<String> matrixDbId, String format, Boolean expandHomozygotes, String unknownString, String sepPhased, String sepUnphased, Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/allelematrices-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "markerprofileDbId", markerprofileDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "markerDbId", markerDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "matrixDbId", matrixDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "expandHomozygotes", expandHomozygotes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "unknownString", unknownString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepPhased", sepPhased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepUnphased", sepUnphased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AlleleMatrixValuesResponse) ApiInvoker.deserialize(localVarResponse, "", AlleleMatrixValuesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Scores through GET
   * Status: ACCEPTED.  Implemented by: Germinate (POST only), Cassavabase  Used by: Flapjack (POST only)  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  This uses a more efficient data structure and pagination for large number of markers.  See Search Services for additional implementation details. &lt;/br&gt; This uses a more efficient data structure and pagination for large number of markers.  &lt;/br&gt; Use GET when parameter size is less than 2K bytes. This method may support asynchronous processing.
   * @param markerprofileDbId The markerprofile db ids. Not Required if &#39;markerDbId&#39; or &#39;matrixDbId&#39; is present.   * @param markerDbId ids of the markers. if none are specified, results are returned for all markers in the database. Not Required if &#39;markerprofileDbId&#39; or &#39;matrixDbId&#39; is present.   * @param matrixDbId    * @param format format for the datafile to be downloaded. tsv and csv currently supported; flapjack may be supported.   * @param expandHomozygotes Should homozygotes NOT be collapsed into a single occurrence?   * @param unknownString The string to use as a representation for missing data or the reserved word \&quot;empty_string\&quot;.   * @param sepPhased The string to use as a separator for phased allele calls or the reserved word \&quot;empty_string\&quot;.   * @param sepUnphased The string to use as a separator for unphased allele calls or the reserved word \&quot;empty_string\&quot;.   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
  */
  public void allelematricesSearchGet (List<String> markerprofileDbId, List<String> markerDbId, List<String> matrixDbId, String format, Boolean expandHomozygotes, String unknownString, String sepPhased, String sepUnphased, Integer pageSize, Integer page, final Response.Listener<AlleleMatrixValuesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/allelematrices-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "markerprofileDbId", markerprofileDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "markerDbId", markerDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "matrixDbId", matrixDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "expandHomozygotes", expandHomozygotes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "unknownString", unknownString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepPhased", sepPhased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepUnphased", sepUnphased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AlleleMatrixValuesResponse) ApiInvoker.deserialize(localVarResponse,  "", AlleleMatrixValuesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Scores through POST
  * Status: ACCEPTED.  Implemented by: Germinate (POST only), Cassavabase  Used by: Flapjack (POST only)  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  This uses a more efficient data structure and pagination for large number of markers.  Use POST when parameter size is greater than 2K bytes.  - If no format is specified, this call returns the data in JSON form.  - If a format (other than JSON) is specified and the server supports this format, it will return the link to the exported data file in the \&quot;datafiles\&quot; field of the \&quot;metadata\&quot;.  - If more than one format is requested at a time, the server will throw a \&quot;501 Not Implemented\&quot; error.  The format of the tsv response can be found on GitHub (https://github.com/plantbreeding/Documentation/wiki/BrAPI-TSV-Expected-Formats)
   * @param markerprofileDbId The markerprofile db ids. Not Required if &#39;markerDbId&#39; or &#39;matrixDbId&#39; is present.
   * @return AlleleMatrixValuesResponse
  */
  public AlleleMatrixValuesResponse allelematricesSearchPost (AlleleMatrixSearchRequest markerprofileDbId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = markerprofileDbId;
    // verify the required parameter 'markerprofileDbId' is set
    if (markerprofileDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'markerprofileDbId' when calling allelematricesSearchPost",
        new ApiException(400, "Missing the required parameter 'markerprofileDbId' when calling allelematricesSearchPost"));
    }

    // create path and map variables
    String path = "/allelematrices-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AlleleMatrixValuesResponse) ApiInvoker.deserialize(localVarResponse, "", AlleleMatrixValuesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Scores through POST
   * Status: ACCEPTED.  Implemented by: Germinate (POST only), Cassavabase  Used by: Flapjack (POST only)  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  This uses a more efficient data structure and pagination for large number of markers.  Use POST when parameter size is greater than 2K bytes.  - If no format is specified, this call returns the data in JSON form.  - If a format (other than JSON) is specified and the server supports this format, it will return the link to the exported data file in the \&quot;datafiles\&quot; field of the \&quot;metadata\&quot;.  - If more than one format is requested at a time, the server will throw a \&quot;501 Not Implemented\&quot; error.  The format of the tsv response can be found on GitHub (https://github.com/plantbreeding/Documentation/wiki/BrAPI-TSV-Expected-Formats)
   * @param markerprofileDbId The markerprofile db ids. Not Required if &#39;markerDbId&#39; or &#39;matrixDbId&#39; is present.
  */
  public void allelematricesSearchPost (AlleleMatrixSearchRequest markerprofileDbId, final Response.Listener<AlleleMatrixValuesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = markerprofileDbId;

    // verify the required parameter 'markerprofileDbId' is set
    if (markerprofileDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'markerprofileDbId' when calling allelematricesSearchPost",
        new ApiException(400, "Missing the required parameter 'markerprofileDbId' when calling allelematricesSearchPost"));
    }

    // create path and map variables
    String path = "/allelematrices-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AlleleMatrixValuesResponse) ApiInvoker.deserialize(localVarResponse,  "", AlleleMatrixValuesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Scores through GET
  * Status: ACCEPTED.  Implemented by: Germinate (POST only), Cassavabase  Used by: Flapjack (POST only)  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  This uses a more efficient data structure and pagination for large number of markers.  See Search Services for additional implementation details. &lt;/br&gt; This uses a more efficient data structure and pagination for large number of markers.  &lt;/br&gt; Use GET when parameter size is less than 2K bytes. This method may support asynchronous processing.
   * @param markerprofileDbId The markerprofile db ids. Not Required if &#39;markerDbId&#39; or &#39;matrixDbId&#39; is present.
   * @param markerDbId ids of the markers. if none are specified, results are returned for all markers in the database. Not Required if &#39;markerprofileDbId&#39; or &#39;matrixDbId&#39; is present.
   * @param matrixDbId 
   * @param format format for the datafile to be downloaded. tsv and csv currently supported; flapjack may be supported.
   * @param expandHomozygotes Should homozygotes NOT be collapsed into a single occurrence?
   * @param unknownString The string to use as a representation for missing data or the reserved word \&quot;empty_string\&quot;.
   * @param sepPhased The string to use as a separator for phased allele calls or the reserved word \&quot;empty_string\&quot;.
   * @param sepUnphased The string to use as a separator for unphased allele calls or the reserved word \&quot;empty_string\&quot;.
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @return AlleleMatrixValuesResponse
  */
  public AlleleMatrixValuesResponse allelematrixSearchGet (List<String> markerprofileDbId, List<String> markerDbId, List<String> matrixDbId, String format, Boolean expandHomozygotes, String unknownString, String sepPhased, String sepUnphased, Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/allelematrix-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "markerprofileDbId", markerprofileDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "markerDbId", markerDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "matrixDbId", matrixDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "expandHomozygotes", expandHomozygotes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "unknownString", unknownString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepPhased", sepPhased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepUnphased", sepUnphased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AlleleMatrixValuesResponse) ApiInvoker.deserialize(localVarResponse, "", AlleleMatrixValuesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Scores through GET
   * Status: ACCEPTED.  Implemented by: Germinate (POST only), Cassavabase  Used by: Flapjack (POST only)  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  This uses a more efficient data structure and pagination for large number of markers.  See Search Services for additional implementation details. &lt;/br&gt; This uses a more efficient data structure and pagination for large number of markers.  &lt;/br&gt; Use GET when parameter size is less than 2K bytes. This method may support asynchronous processing.
   * @param markerprofileDbId The markerprofile db ids. Not Required if &#39;markerDbId&#39; or &#39;matrixDbId&#39; is present.   * @param markerDbId ids of the markers. if none are specified, results are returned for all markers in the database. Not Required if &#39;markerprofileDbId&#39; or &#39;matrixDbId&#39; is present.   * @param matrixDbId    * @param format format for the datafile to be downloaded. tsv and csv currently supported; flapjack may be supported.   * @param expandHomozygotes Should homozygotes NOT be collapsed into a single occurrence?   * @param unknownString The string to use as a representation for missing data or the reserved word \&quot;empty_string\&quot;.   * @param sepPhased The string to use as a separator for phased allele calls or the reserved word \&quot;empty_string\&quot;.   * @param sepUnphased The string to use as a separator for unphased allele calls or the reserved word \&quot;empty_string\&quot;.   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
  */
  public void allelematrixSearchGet (List<String> markerprofileDbId, List<String> markerDbId, List<String> matrixDbId, String format, Boolean expandHomozygotes, String unknownString, String sepPhased, String sepUnphased, Integer pageSize, Integer page, final Response.Listener<AlleleMatrixValuesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/allelematrix-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "markerprofileDbId", markerprofileDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "markerDbId", markerDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "matrixDbId", matrixDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "expandHomozygotes", expandHomozygotes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "unknownString", unknownString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepPhased", sepPhased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepUnphased", sepUnphased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AlleleMatrixValuesResponse) ApiInvoker.deserialize(localVarResponse,  "", AlleleMatrixValuesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Scores through POST
  * Status: ACCEPTED.  Implemented by: Germinate (POST only), Cassavabase  Used by: Flapjack (POST only)  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  This uses a more efficient data structure and pagination for large number of markers.  Use POST when parameter size is greater than 2K bytes.  - If no format is specified, this call returns the data in JSON form.  - If a format (other than JSON) is specified and the server supports this format, it will return the link to the exported data file in the \&quot;datafiles\&quot; field of the \&quot;metadata\&quot;.  - If more than one format is requested at a time, the server will throw a \&quot;501 Not Implemented\&quot; error.  The format of the tsv response can be found on GitHub (https://github.com/plantbreeding/Documentation/wiki/BrAPI-TSV-Expected-Formats)
   * @param markerprofileDbId The markerprofile db ids. Not Required if &#39;markerDbId&#39; or &#39;matrixDbId&#39; is present.
   * @return AlleleMatrixValuesResponse
  */
  public AlleleMatrixValuesResponse allelematrixSearchPost (AlleleMatrixSearchRequest markerprofileDbId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = markerprofileDbId;
    // verify the required parameter 'markerprofileDbId' is set
    if (markerprofileDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'markerprofileDbId' when calling allelematrixSearchPost",
        new ApiException(400, "Missing the required parameter 'markerprofileDbId' when calling allelematrixSearchPost"));
    }

    // create path and map variables
    String path = "/allelematrix-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AlleleMatrixValuesResponse) ApiInvoker.deserialize(localVarResponse, "", AlleleMatrixValuesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Scores through POST
   * Status: ACCEPTED.  Implemented by: Germinate (POST only), Cassavabase  Used by: Flapjack (POST only)  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  This uses a more efficient data structure and pagination for large number of markers.  Use POST when parameter size is greater than 2K bytes.  - If no format is specified, this call returns the data in JSON form.  - If a format (other than JSON) is specified and the server supports this format, it will return the link to the exported data file in the \&quot;datafiles\&quot; field of the \&quot;metadata\&quot;.  - If more than one format is requested at a time, the server will throw a \&quot;501 Not Implemented\&quot; error.  The format of the tsv response can be found on GitHub (https://github.com/plantbreeding/Documentation/wiki/BrAPI-TSV-Expected-Formats)
   * @param markerprofileDbId The markerprofile db ids. Not Required if &#39;markerDbId&#39; or &#39;matrixDbId&#39; is present.
  */
  public void allelematrixSearchPost (AlleleMatrixSearchRequest markerprofileDbId, final Response.Listener<AlleleMatrixValuesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = markerprofileDbId;

    // verify the required parameter 'markerprofileDbId' is set
    if (markerprofileDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'markerprofileDbId' when calling allelematrixSearchPost",
        new ApiException(400, "Missing the required parameter 'markerprofileDbId' when calling allelematrixSearchPost"));
    }

    // create path and map variables
    String path = "/allelematrix-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AlleleMatrixValuesResponse) ApiInvoker.deserialize(localVarResponse,  "", AlleleMatrixValuesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Retrieve Markerprofile Ids
  * &lt;strong&gt;Scope&lt;/strong&gt;: GENOTYPING. &lt;strong&gt;Status&lt;/strong&gt;: ACCEPTED. &lt;strong&gt;Implemented by&lt;/strong&gt;: Germinate &lt;strong&gt;Used by&lt;/strong&gt;: Flapjack &lt;/br&gt; For the requested Germplasm Id and/or Extract Id, returns the Markerprofile Id and number of non-missing allele calls (marker/allele pairs).
   * @param germplasmDbId The server&#39;s internal ids for the Germplasm IDs, as returned by the &lt;strong&gt;Find markerprofile by Germplasm&lt;/strong&gt; service.
   * @param studyDbId The server&#39;s internal id for the StudyDbId
   * @param sampleDbId The server&#39;s internal id for the SampleDbId
   * @param extractDbId The server&#39;s internal id for the ExtractDbId
   * @param pageSize The number of allele call results (marker/allele pairs) to be returned in the response. If multiple experiments are requested, some responses will contain the last results from one experiment followed by the first results from the next.
   * @param page Required if &#x60;pageSize&#x60; is given; and requires that &#x60;pageSize&#x60; be given. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D;0)
   * @return MarkerProfileDescriptionsResponse
  */
  public MarkerProfileDescriptionsResponse markerprofilesGet (String germplasmDbId, String studyDbId, String sampleDbId, String extractDbId, Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/markerprofiles";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "germplasmDbId", germplasmDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "studyDbId", studyDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sampleDbId", sampleDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "extractDbId", extractDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (MarkerProfileDescriptionsResponse) ApiInvoker.deserialize(localVarResponse, "", MarkerProfileDescriptionsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Retrieve Markerprofile Ids
   * &lt;strong&gt;Scope&lt;/strong&gt;: GENOTYPING. &lt;strong&gt;Status&lt;/strong&gt;: ACCEPTED. &lt;strong&gt;Implemented by&lt;/strong&gt;: Germinate &lt;strong&gt;Used by&lt;/strong&gt;: Flapjack &lt;/br&gt; For the requested Germplasm Id and/or Extract Id, returns the Markerprofile Id and number of non-missing allele calls (marker/allele pairs).
   * @param germplasmDbId The server&#39;s internal ids for the Germplasm IDs, as returned by the &lt;strong&gt;Find markerprofile by Germplasm&lt;/strong&gt; service.   * @param studyDbId The server&#39;s internal id for the StudyDbId   * @param sampleDbId The server&#39;s internal id for the SampleDbId   * @param extractDbId The server&#39;s internal id for the ExtractDbId   * @param pageSize The number of allele call results (marker/allele pairs) to be returned in the response. If multiple experiments are requested, some responses will contain the last results from one experiment followed by the first results from the next.   * @param page Required if &#x60;pageSize&#x60; is given; and requires that &#x60;pageSize&#x60; be given. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D;0)
  */
  public void markerprofilesGet (String germplasmDbId, String studyDbId, String sampleDbId, String extractDbId, Integer pageSize, Integer page, final Response.Listener<MarkerProfileDescriptionsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/markerprofiles".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "germplasmDbId", germplasmDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "studyDbId", studyDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sampleDbId", sampleDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "extractDbId", extractDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((MarkerProfileDescriptionsResponse) ApiInvoker.deserialize(localVarResponse,  "", MarkerProfileDescriptionsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Alleles By Markerprofile Id
  * &lt;strong&gt;Scope&lt;/strong&gt;:GENOTYPING. &lt;strong&gt;Status&lt;/strong&gt;: ACCEPTED. &lt;strong&gt;Implemented by&lt;/strong&gt;: Germinate, Cassavabase &lt;/br&gt; For the requested markerprofile ID, returns the allele call for each marker.  [Example](http://malt.pw.usda.gov/t3/wheatplus/markerprofiles/1784_99/count?analysisMethod&#x3D;GoldenGate) &lt;/br&gt; &lt;strong&gt;Allele encodings&lt;/strong&gt;  - Unknown data will by default be encoded by \&quot;N\&quot; - Homozygotes are returned as a single occurance, e.g. AA -&gt; A, GG -&gt; G - Phased heterozygotes are by default separated by a pipe (\&quot;|\&quot;) and unphased heterozygotes are by default separated by a forward slash (\&quot;/\&quot;) - Dominant markers such as DArTs: 1 for present, 0 for absent  &lt;strong&gt;Parameters&lt;/strong&gt; - If the user would like to use an empty string (\&quot;\&quot;) for any of the parameters, the value should be set to the reserved word \&quot;empty_string\&quot;, e.g. sepUnphased&#x3D;empty_string.  &lt;strong&gt;Open issue:&lt;/strong&gt; The pages of data will need to be sorted sensibly in order for the requested page to be delivered consistently.  By map or genome position? Alphabetically?&#39;
   * @param markerprofileDbId The server&#39;s internal id for the markerprofile
   * @param expandHomozygotes Should homozygotes NOT be collapsed into a single orrucance?
   * @param unknownString The string to use as a representation for missing data or the reserved word \&quot;empty_string\&quot;.
   * @param sepPhased The string to use as a separator for phased allele calls or the reserved word \&quot;empty_string\&quot;.
   * @param sepUnphased The string to use as a separator for unphased allele calls or the reserved word \&quot;empty_string\&quot;.
   * @param pageSize The number of allele call results (marker/allele pairs) to be returned in the response. If multiple experiments are requested, some responses will contain the last results from one experiment followed by the first results from the next.
   * @param page Required if &#x60;pageSize&#x60; is given; and requires that &#x60;pageSize&#x60; be given. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D;0)
   * @return MarkerProfilesResponse
  */
  public MarkerProfilesResponse markerprofilesMarkerprofileDbIdGet (String markerprofileDbId, Boolean expandHomozygotes, String unknownString, String sepPhased, String sepUnphased, Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'markerprofileDbId' is set
    if (markerprofileDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'markerprofileDbId' when calling markerprofilesMarkerprofileDbIdGet",
        new ApiException(400, "Missing the required parameter 'markerprofileDbId' when calling markerprofilesMarkerprofileDbIdGet"));
    }

    // create path and map variables
    String path = "/markerprofiles/{markerprofileDbId}".replaceAll("\\{" + "markerprofileDbId" + "\\}", apiInvoker.escapeString(markerprofileDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "expandHomozygotes", expandHomozygotes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "unknownString", unknownString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepPhased", sepPhased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepUnphased", sepUnphased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (MarkerProfilesResponse) ApiInvoker.deserialize(localVarResponse, "", MarkerProfilesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Alleles By Markerprofile Id
   * &lt;strong&gt;Scope&lt;/strong&gt;:GENOTYPING. &lt;strong&gt;Status&lt;/strong&gt;: ACCEPTED. &lt;strong&gt;Implemented by&lt;/strong&gt;: Germinate, Cassavabase &lt;/br&gt; For the requested markerprofile ID, returns the allele call for each marker.  [Example](http://malt.pw.usda.gov/t3/wheatplus/markerprofiles/1784_99/count?analysisMethod&#x3D;GoldenGate) &lt;/br&gt; &lt;strong&gt;Allele encodings&lt;/strong&gt;  - Unknown data will by default be encoded by \&quot;N\&quot; - Homozygotes are returned as a single occurance, e.g. AA -&gt; A, GG -&gt; G - Phased heterozygotes are by default separated by a pipe (\&quot;|\&quot;) and unphased heterozygotes are by default separated by a forward slash (\&quot;/\&quot;) - Dominant markers such as DArTs: 1 for present, 0 for absent  &lt;strong&gt;Parameters&lt;/strong&gt; - If the user would like to use an empty string (\&quot;\&quot;) for any of the parameters, the value should be set to the reserved word \&quot;empty_string\&quot;, e.g. sepUnphased&#x3D;empty_string.  &lt;strong&gt;Open issue:&lt;/strong&gt; The pages of data will need to be sorted sensibly in order for the requested page to be delivered consistently.  By map or genome position? Alphabetically?&#39;
   * @param markerprofileDbId The server&#39;s internal id for the markerprofile   * @param expandHomozygotes Should homozygotes NOT be collapsed into a single orrucance?   * @param unknownString The string to use as a representation for missing data or the reserved word \&quot;empty_string\&quot;.   * @param sepPhased The string to use as a separator for phased allele calls or the reserved word \&quot;empty_string\&quot;.   * @param sepUnphased The string to use as a separator for unphased allele calls or the reserved word \&quot;empty_string\&quot;.   * @param pageSize The number of allele call results (marker/allele pairs) to be returned in the response. If multiple experiments are requested, some responses will contain the last results from one experiment followed by the first results from the next.   * @param page Required if &#x60;pageSize&#x60; is given; and requires that &#x60;pageSize&#x60; be given. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D;0)
  */
  public void markerprofilesMarkerprofileDbIdGet (String markerprofileDbId, Boolean expandHomozygotes, String unknownString, String sepPhased, String sepUnphased, Integer pageSize, Integer page, final Response.Listener<MarkerProfilesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'markerprofileDbId' is set
    if (markerprofileDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'markerprofileDbId' when calling markerprofilesMarkerprofileDbIdGet",
        new ApiException(400, "Missing the required parameter 'markerprofileDbId' when calling markerprofilesMarkerprofileDbIdGet"));
    }

    // create path and map variables
    String path = "/markerprofiles/{markerprofileDbId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "markerprofileDbId" + "\\}", apiInvoker.escapeString(markerprofileDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "expandHomozygotes", expandHomozygotes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "unknownString", unknownString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepPhased", sepPhased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepUnphased", sepUnphased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((MarkerProfilesResponse) ApiInvoker.deserialize(localVarResponse,  "", MarkerProfilesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
