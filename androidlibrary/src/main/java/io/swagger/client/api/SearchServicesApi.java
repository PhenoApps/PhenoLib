/**
 * BrAPI
 * The Breeding API (BrAPI) is a Standardized RESTful Web Service API Specification for communicating Plant Breeding Data. BrAPI allows for easy data sharing between databases and tools involved in plant breeding.  <strong>General Reference Documentation</strong> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/URL_Structure.md\">URL Structure</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Response_Structure.md\">Response Structure</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Date_Time_Encoding.md\">Date/Time Encoding</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Location_Encoding.md\">Location Encoding</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Error_Handling.md\">Error Handling</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Search_Services.md\">Search Services</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Asychronous_Processing.md\">Asynchronous Processing</a>
 *
 * OpenAPI spec version: 1.2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api;

import io.swagger.client.ApiInvoker;
import io.swagger.client.ApiException;
import io.swagger.client.Pair;

import io.swagger.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import java.util.Date;
import io.swagger.client.model.GermplasmResponse;
import io.swagger.client.model.GermplasmSearchRequest;
import io.swagger.client.model.ObservationUnitsResponse;
import io.swagger.client.model.ObservationUnitsTableResponse1;
import io.swagger.client.model.PhenotypesSearchRequest;
import io.swagger.client.model.ProgramsResponse;
import io.swagger.client.model.ProgramsSearchRequest;
import io.swagger.client.model.SampleSearchRequest;
import io.swagger.client.model.SamplesResponse;
import io.swagger.client.model.StudiesResponse;
import io.swagger.client.model.StudySearchRequest;
import io.swagger.client.model.VendorPlateSearchRequest;
import io.swagger.client.model.VendorPlatesResponse;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class SearchServicesApi {
  String basePath = "https://test-server.brapi.org/brapi/v1";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Germplasm search through GET
  *  Implemented by: GnpIS, Germinate (GET only) See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details. Notes: The germplasm and germplasm MCPD calls were merged.  The MCPD fields are optional and indicated as such with the [MCPD] prefix in the description field of the \&quot;Response data types\&quot; table. Please use the \&quot;features\&quot; hash of the \&quot;calls\&quot; call to communicate with clients as to whether MCPD is supported by your implementation. Addresses these needs: 1. General germplasm search mechanism that accepts POST for complex queries 2. possibility to search germplasm by more parameters than those allowed by the existing germplasm search 3. possibility to get MCPD details by PUID rather than dbId Use GET when parameter size is less than 2K bytes. &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/germplasm\&quot;&gt; test-server.brapi.org/brapi/v1/germplasm-search&lt;/a&gt; 
   * @param germplasmPUI Permanent unique identifier (DOI, URI, etc.)
   * @param germplasmDbId Internal database identifier
   * @param germplasmName Name of the germplasm
   * @param commonCropName The common crop name related to this germplasm
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @return GermplasmResponse
  */
  public GermplasmResponse germplasmSearchGet (String germplasmPUI, String germplasmDbId, String germplasmName, String commonCropName, Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/germplasm-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "germplasmPUI", germplasmPUI));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "germplasmDbId", germplasmDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "germplasmName", germplasmName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "commonCropName", commonCropName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (GermplasmResponse) ApiInvoker.deserialize(localVarResponse, "", GermplasmResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Germplasm search through GET
   *  Implemented by: GnpIS, Germinate (GET only) See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details. Notes: The germplasm and germplasm MCPD calls were merged.  The MCPD fields are optional and indicated as such with the [MCPD] prefix in the description field of the \&quot;Response data types\&quot; table. Please use the \&quot;features\&quot; hash of the \&quot;calls\&quot; call to communicate with clients as to whether MCPD is supported by your implementation. Addresses these needs: 1. General germplasm search mechanism that accepts POST for complex queries 2. possibility to search germplasm by more parameters than those allowed by the existing germplasm search 3. possibility to get MCPD details by PUID rather than dbId Use GET when parameter size is less than 2K bytes. &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/germplasm\&quot;&gt; test-server.brapi.org/brapi/v1/germplasm-search&lt;/a&gt; 
   * @param germplasmPUI Permanent unique identifier (DOI, URI, etc.)   * @param germplasmDbId Internal database identifier   * @param germplasmName Name of the germplasm   * @param commonCropName The common crop name related to this germplasm   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
  */
  public void germplasmSearchGet (String germplasmPUI, String germplasmDbId, String germplasmName, String commonCropName, Integer pageSize, Integer page, final Response.Listener<GermplasmResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/germplasm-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "germplasmPUI", germplasmPUI));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "germplasmDbId", germplasmDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "germplasmName", germplasmName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "commonCropName", commonCropName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((GermplasmResponse) ApiInvoker.deserialize(localVarResponse,  "", GermplasmResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Germplasm search through POST
  *  Implemented by: GnpIS, Germinate (GET only) See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details. Notes: The germplasm and germplasm MCPD calls were merged.  The MCPD fields are optional and indicated as such with the [MCPD] prefix in the description field of the \&quot;Response data types\&quot; table. Please use the \&quot;features\&quot; hash of the \&quot;calls\&quot; call to communicate with clients as to whether MCPD is supported by your implementation. Addresses these needs: 1. General germplasm search mechanism that accepts POST for complex queries 2. possibility to search germplasm by more parameters than those allowed by the existing germplasm search 3. possibility to get MCPD details by PUID rather than dbId Use POST for large queries (&gt;2K bytes). 
   * @param body 
   * @return GermplasmResponse
  */
  public GermplasmResponse germplasmSearchPost (GermplasmSearchRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;

    // create path and map variables
    String path = "/germplasm-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (GermplasmResponse) ApiInvoker.deserialize(localVarResponse, "", GermplasmResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Germplasm search through POST
   *  Implemented by: GnpIS, Germinate (GET only) See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details. Notes: The germplasm and germplasm MCPD calls were merged.  The MCPD fields are optional and indicated as such with the [MCPD] prefix in the description field of the \&quot;Response data types\&quot; table. Please use the \&quot;features\&quot; hash of the \&quot;calls\&quot; call to communicate with clients as to whether MCPD is supported by your implementation. Addresses these needs: 1. General germplasm search mechanism that accepts POST for complex queries 2. possibility to search germplasm by more parameters than those allowed by the existing germplasm search 3. possibility to get MCPD details by PUID rather than dbId Use POST for large queries (&gt;2K bytes). 
   * @param body 
  */
  public void germplasmSearchPost (GermplasmSearchRequest body, final Response.Listener<GermplasmResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;


    // create path and map variables
    String path = "/germplasm-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((GermplasmResponse) ApiInvoker.deserialize(localVarResponse,  "", GermplasmResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Phenotype Search CSV
  * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.        observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
   * @return String
  */
  public String phenotypesSearchCsvPost (PhenotypesSearchRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;

    // create path and map variables
    String path = "/phenotypes-search/csv";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (String) ApiInvoker.deserialize(localVarResponse, "", String.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Phenotype Search CSV
   * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.        observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
  */
  public void phenotypesSearchCsvPost (PhenotypesSearchRequest body, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;


    // create path and map variables
    String path = "/phenotypes-search/csv".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((String) ApiInvoker.deserialize(localVarResponse,  "", String.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Phenotype Search
  * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  Implemented for GnpIS and PHIS data (https://urgi.versailles.inra.fr/ws/webresources/brapi/v1/phenotypes).  Use case: this section allows to get a dataset from multiple studies. It allows to integrate data from several databases. Refactor note : This call allows to get and integrate portions of multiple phenotyping data matrixes. A proposed evolution allowed to get a list of single observations, this functionality is still possible with this call by specifybing the observation variable, see below. Example Use cases: - Study a panel of germplasm accross multiple studies, search parameters : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ]} - Get all data for a specific study : {\&quot;studyDbIds\&quot; : [ \&quot;383\&quot; ]} - Get simple atomic phenotyping values : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ], \&quot;observationVariableDbIds\&quot; : [ \&quot;CO_345:0000043\&quot;]} - Study Locations for adaptation to climat change : {\&quot;locationDbIds\&quot; : [ \&quot;383838\&quot;, \&quot;MONTPELLIER\&quot; ], \&quot;germplasmDbIds\&quot; : [ \&quot;all ids for a given species\&quot;]} - Find phenotypes that are from after a certain timestamp  observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param germplasmDbId The name or synonym of external genebank accession identifiers
   * @param observationVariableDbId The ID of traits, could be ontology ID, database ID or PUI
   * @param studyDbId The database ID / PK of the studies search parameter
   * @param locationDbId locations these traits were collected
   * @param trialDbId trial to search across
   * @param programDbId program that have phenotyped this trait
   * @param seasonDbId The year or Phenotyping campaign of a multi-annual study (trees, grape, ...)
   * @param observationLevel The type of the observationUnit. Returns only the observation unit of the specified type; the parent levels ID can be accessed through observationUnitStructure.
   * @param observationTimeStampRangeStart Timestamp range start
   * @param observationTimeStampRangeEnd Timestamp range end
   * @param pageSize The size of the pages to be returned. Default is 1000.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is 0.
   * @return ObservationUnitsResponse
  */
  public ObservationUnitsResponse phenotypesSearchGet (String germplasmDbId, String observationVariableDbId, String studyDbId, String locationDbId, String trialDbId, String programDbId, String seasonDbId, String observationLevel, Date observationTimeStampRangeStart, Date observationTimeStampRangeEnd, Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/phenotypes-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "germplasmDbId", germplasmDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationVariableDbId", observationVariableDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "studyDbId", studyDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationDbId", locationDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "trialDbId", trialDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "programDbId", programDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "seasonDbId", seasonDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationLevel", observationLevel));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationTimeStampRangeStart", observationTimeStampRangeStart));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationTimeStampRangeEnd", observationTimeStampRangeEnd));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObservationUnitsResponse) ApiInvoker.deserialize(localVarResponse, "", ObservationUnitsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Phenotype Search
   * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  Implemented for GnpIS and PHIS data (https://urgi.versailles.inra.fr/ws/webresources/brapi/v1/phenotypes).  Use case: this section allows to get a dataset from multiple studies. It allows to integrate data from several databases. Refactor note : This call allows to get and integrate portions of multiple phenotyping data matrixes. A proposed evolution allowed to get a list of single observations, this functionality is still possible with this call by specifybing the observation variable, see below. Example Use cases: - Study a panel of germplasm accross multiple studies, search parameters : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ]} - Get all data for a specific study : {\&quot;studyDbIds\&quot; : [ \&quot;383\&quot; ]} - Get simple atomic phenotyping values : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ], \&quot;observationVariableDbIds\&quot; : [ \&quot;CO_345:0000043\&quot;]} - Study Locations for adaptation to climat change : {\&quot;locationDbIds\&quot; : [ \&quot;383838\&quot;, \&quot;MONTPELLIER\&quot; ], \&quot;germplasmDbIds\&quot; : [ \&quot;all ids for a given species\&quot;]} - Find phenotypes that are from after a certain timestamp  observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param germplasmDbId The name or synonym of external genebank accession identifiers   * @param observationVariableDbId The ID of traits, could be ontology ID, database ID or PUI   * @param studyDbId The database ID / PK of the studies search parameter   * @param locationDbId locations these traits were collected   * @param trialDbId trial to search across   * @param programDbId program that have phenotyped this trait   * @param seasonDbId The year or Phenotyping campaign of a multi-annual study (trees, grape, ...)   * @param observationLevel The type of the observationUnit. Returns only the observation unit of the specified type; the parent levels ID can be accessed through observationUnitStructure.   * @param observationTimeStampRangeStart Timestamp range start   * @param observationTimeStampRangeEnd Timestamp range end   * @param pageSize The size of the pages to be returned. Default is 1000.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is 0.
  */
  public void phenotypesSearchGet (String germplasmDbId, String observationVariableDbId, String studyDbId, String locationDbId, String trialDbId, String programDbId, String seasonDbId, String observationLevel, Date observationTimeStampRangeStart, Date observationTimeStampRangeEnd, Integer pageSize, Integer page, final Response.Listener<ObservationUnitsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/phenotypes-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "germplasmDbId", germplasmDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationVariableDbId", observationVariableDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "studyDbId", studyDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationDbId", locationDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "trialDbId", trialDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "programDbId", programDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "seasonDbId", seasonDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationLevel", observationLevel));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationTimeStampRangeStart", observationTimeStampRangeStart));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationTimeStampRangeEnd", observationTimeStampRangeEnd));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObservationUnitsResponse) ApiInvoker.deserialize(localVarResponse,  "", ObservationUnitsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Phenotype Search
  * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  Implemented for GnpIS and PHIS data (https://urgi.versailles.inra.fr/ws/webresources/brapi/v1/phenotypes).  Use case: this section allows to get a dataset from multiple studies. It allows to integrate data from several databases. Refactor note : This call allows to get and integrate portions of multiple phenotyping data matrixes. A proposed evolution allowed to get a list of single observations, this functionality is still possible with this call by specifybing the observation variable, see below. Example Use cases: - Study a panel of germplasm accross multiple studies, search parameters : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ]} - Get all data for a specific study : {\&quot;studyDbIds\&quot; : [ \&quot;383\&quot; ]} - Get simple atomic phenotyping values : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ], \&quot;observationVariableDbIds\&quot; : [ \&quot;CO_345:0000043\&quot;]} - Study Locations for adaptation to climat change : {\&quot;locationDbIds\&quot; : [ \&quot;383838\&quot;, \&quot;MONTPELLIER\&quot; ], \&quot;germplasmDbIds\&quot; : [ \&quot;all ids for a given species\&quot;]} - Find phenotypes that are from after a certain timestamp  observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
   * @return ObservationUnitsResponse
  */
  public ObservationUnitsResponse phenotypesSearchPost (PhenotypesSearchRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;

    // create path and map variables
    String path = "/phenotypes-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObservationUnitsResponse) ApiInvoker.deserialize(localVarResponse, "", ObservationUnitsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Phenotype Search
   * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  Implemented for GnpIS and PHIS data (https://urgi.versailles.inra.fr/ws/webresources/brapi/v1/phenotypes).  Use case: this section allows to get a dataset from multiple studies. It allows to integrate data from several databases. Refactor note : This call allows to get and integrate portions of multiple phenotyping data matrixes. A proposed evolution allowed to get a list of single observations, this functionality is still possible with this call by specifybing the observation variable, see below. Example Use cases: - Study a panel of germplasm accross multiple studies, search parameters : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ]} - Get all data for a specific study : {\&quot;studyDbIds\&quot; : [ \&quot;383\&quot; ]} - Get simple atomic phenotyping values : {\&quot;germplasmDbIds\&quot; : [ \&quot;Syrah\&quot;, \&quot;34Mtp362\&quot; ], \&quot;observationVariableDbIds\&quot; : [ \&quot;CO_345:0000043\&quot;]} - Study Locations for adaptation to climat change : {\&quot;locationDbIds\&quot; : [ \&quot;383838\&quot;, \&quot;MONTPELLIER\&quot; ], \&quot;germplasmDbIds\&quot; : [ \&quot;all ids for a given species\&quot;]} - Find phenotypes that are from after a certain timestamp  observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
  */
  public void phenotypesSearchPost (PhenotypesSearchRequest body, final Response.Listener<ObservationUnitsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;


    // create path and map variables
    String path = "/phenotypes-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObservationUnitsResponse) ApiInvoker.deserialize(localVarResponse,  "", ObservationUnitsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Phenotype Search Table
  * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.        observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
   * @return ObservationUnitsTableResponse1
  */
  public ObservationUnitsTableResponse1 phenotypesSearchTablePost (PhenotypesSearchRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;

    // create path and map variables
    String path = "/phenotypes-search/table";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObservationUnitsTableResponse1) ApiInvoker.deserialize(localVarResponse, "", ObservationUnitsTableResponse1.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Phenotype Search Table
   * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.        observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
  */
  public void phenotypesSearchTablePost (PhenotypesSearchRequest body, final Response.Listener<ObservationUnitsTableResponse1> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;


    // create path and map variables
    String path = "/phenotypes-search/table".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObservationUnitsTableResponse1) ApiInvoker.deserialize(localVarResponse,  "", ObservationUnitsTableResponse1.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Phenotype Search TSV
  * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.        observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
   * @return String
  */
  public String phenotypesSearchTsvPost (PhenotypesSearchRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;

    // create path and map variables
    String path = "/phenotypes-search/tsv";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (String) ApiInvoker.deserialize(localVarResponse, "", String.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Phenotype Search TSV
   * Scope: PHENOTYPING. Status: ACCEPTED.  Returns a list of observationUnit with the observed Phenotypes.        observationTimeStamp : Iso Standard 8601.  observationValue data type inferred from the ontology
   * @param body 
  */
  public void phenotypesSearchTsvPost (PhenotypesSearchRequest body, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;


    // create path and map variables
    String path = "/phenotypes-search/tsv".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((String) ApiInvoker.deserialize(localVarResponse,  "", String.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Programs
  *  Advanced searching for the programs resource. Status: ACCEPTED. See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details. 
   * @param body 
   * @return ProgramsResponse
  */
  public ProgramsResponse programsSearchPost (ProgramsSearchRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;

    // create path and map variables
    String path = "/programs-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ProgramsResponse) ApiInvoker.deserialize(localVarResponse, "", ProgramsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Programs
   *  Advanced searching for the programs resource. Status: ACCEPTED. See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details. 
   * @param body 
  */
  public void programsSearchPost (ProgramsSearchRequest body, final Response.Listener<ProgramsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;


    // create path and map variables
    String path = "/programs-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ProgramsResponse) ApiInvoker.deserialize(localVarResponse,  "", ProgramsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Sample Search
  *  Used to retrieve list of Samples from a Sample Tracking system based on some search criteria. &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/samples\&quot;&gt; test-server.brapi.org/brapi/v1/samples-search&lt;/a&gt;
   * @param sampleDbId the internal DB id for a sample
   * @param observationUnitDbId the internal DB id for an observation unit where a sample was taken from
   * @param plateDbId the internal DB id for a plate of samples
   * @param germplasmDbId the internal DB id for a germplasm
   * @param pageSize The size of the pages to be returned. Default is 1000.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is 0.
   * @return SamplesResponse
  */
  public SamplesResponse samplesSearchGet (String sampleDbId, String observationUnitDbId, String plateDbId, String germplasmDbId, Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/samples-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sampleDbId", sampleDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationUnitDbId", observationUnitDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "plateDbId", plateDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "germplasmDbId", germplasmDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SamplesResponse) ApiInvoker.deserialize(localVarResponse, "", SamplesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Sample Search
   *  Used to retrieve list of Samples from a Sample Tracking system based on some search criteria. &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/samples\&quot;&gt; test-server.brapi.org/brapi/v1/samples-search&lt;/a&gt;
   * @param sampleDbId the internal DB id for a sample   * @param observationUnitDbId the internal DB id for an observation unit where a sample was taken from   * @param plateDbId the internal DB id for a plate of samples   * @param germplasmDbId the internal DB id for a germplasm   * @param pageSize The size of the pages to be returned. Default is 1000.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is 0.
  */
  public void samplesSearchGet (String sampleDbId, String observationUnitDbId, String plateDbId, String germplasmDbId, Integer pageSize, Integer page, final Response.Listener<SamplesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/samples-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "sampleDbId", sampleDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationUnitDbId", observationUnitDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "plateDbId", plateDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "germplasmDbId", germplasmDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SamplesResponse) ApiInvoker.deserialize(localVarResponse,  "", SamplesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Post Sample Search
  *  Used to retrieve list of Samples from a Sample Tracking system based on some search criteria. &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/samples\&quot;&gt; test-server.brapi.org/brapi/v1/samples-search&lt;/a&gt;
   * @param sampleSearch 
   * @return SamplesResponse
  */
  public SamplesResponse samplesSearchPost (SampleSearchRequest sampleSearch) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = sampleSearch;

    // create path and map variables
    String path = "/samples-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SamplesResponse) ApiInvoker.deserialize(localVarResponse, "", SamplesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Post Sample Search
   *  Used to retrieve list of Samples from a Sample Tracking system based on some search criteria. &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/samples\&quot;&gt; test-server.brapi.org/brapi/v1/samples-search&lt;/a&gt;
   * @param sampleSearch 
  */
  public void samplesSearchPost (SampleSearchRequest sampleSearch, final Response.Listener<SamplesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = sampleSearch;


    // create path and map variables
    String path = "/samples-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SamplesResponse) ApiInvoker.deserialize(localVarResponse,  "", SamplesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Studies (GET)
  *  Scope: PHENOTYPING. Status: ACCEPTED. Implementation target date: PAG2016. Implemented by: Germinate Used by: Flapjack, Cassavabase See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details. Get list of studies StartDate and endDate should be ISO8601 format for dates: YYYY-MM-DD &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/studies\&quot;&gt; test-server.brapi.org/brapi/v1/studies-search&lt;/a&gt;
   * @param studyType Filter based on study type e.g. Nursery, Trial or Genotype.
   * @param programDbId Program filter to only return studies associated with given program id.
   * @param locationDbId Filter by location
   * @param seasonDbId Filter by season or year
   * @param trialDbId Filter by trial
   * @param studyDbId Filter by study DbId
   * @param germplasmDbIds Filter studies where specified germplasm have been used/tested
   * @param observationVariableDbIds Filter studies where specified observation variables have been measured
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @param active Filter active status true/false.
   * @param sortBy Sort order. Name of the field to sort by.
   * @param sortOrder Sort order direction. Ascending/Descending.
   * @return StudiesResponse
  */
  public StudiesResponse studiesSearchGet (String studyType, String programDbId, String locationDbId, String seasonDbId, String trialDbId, String studyDbId, List<String> germplasmDbIds, List<String> observationVariableDbIds, Integer pageSize, Integer page, Boolean active, String sortBy, String sortOrder) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/studies-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "studyType", studyType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "programDbId", programDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationDbId", locationDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "seasonDbId", seasonDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "trialDbId", trialDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "studyDbId", studyDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "germplasmDbIds", germplasmDbIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "observationVariableDbIds", observationVariableDbIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "active", active));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortBy", sortBy));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortOrder", sortOrder));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (StudiesResponse) ApiInvoker.deserialize(localVarResponse, "", StudiesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Studies (GET)
   *  Scope: PHENOTYPING. Status: ACCEPTED. Implementation target date: PAG2016. Implemented by: Germinate Used by: Flapjack, Cassavabase See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details. Get list of studies StartDate and endDate should be ISO8601 format for dates: YYYY-MM-DD &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/studies\&quot;&gt; test-server.brapi.org/brapi/v1/studies-search&lt;/a&gt;
   * @param studyType Filter based on study type e.g. Nursery, Trial or Genotype.   * @param programDbId Program filter to only return studies associated with given program id.   * @param locationDbId Filter by location   * @param seasonDbId Filter by season or year   * @param trialDbId Filter by trial   * @param studyDbId Filter by study DbId   * @param germplasmDbIds Filter studies where specified germplasm have been used/tested   * @param observationVariableDbIds Filter studies where specified observation variables have been measured   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.   * @param active Filter active status true/false.   * @param sortBy Sort order. Name of the field to sort by.   * @param sortOrder Sort order direction. Ascending/Descending.
  */
  public void studiesSearchGet (String studyType, String programDbId, String locationDbId, String seasonDbId, String trialDbId, String studyDbId, List<String> germplasmDbIds, List<String> observationVariableDbIds, Integer pageSize, Integer page, Boolean active, String sortBy, String sortOrder, final Response.Listener<StudiesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/studies-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "studyType", studyType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "programDbId", programDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationDbId", locationDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "seasonDbId", seasonDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "trialDbId", trialDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "studyDbId", studyDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "germplasmDbIds", germplasmDbIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "observationVariableDbIds", observationVariableDbIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "active", active));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortBy", sortBy));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortOrder", sortOrder));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((StudiesResponse) ApiInvoker.deserialize(localVarResponse,  "", StudiesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Studies (GET)
  *  Scope: PHENOTYPING. Status: ACCEPTED. Implementation target date: PAG2016. Implemented by: Germinate Used by: Flapjack, Cassavabase See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details. Get list of studies StartDate and endDate should be ISO8601 format for dates: YYYY-MM-DD &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/studies\&quot;&gt; test-server.brapi.org/brapi/v1/studies-search&lt;/a&gt;
   * @param studySearchRequest Study Search request
   * @return StudiesResponse
  */
  public StudiesResponse studiesSearchPost (StudySearchRequest studySearchRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = studySearchRequest;

    // create path and map variables
    String path = "/studies-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (StudiesResponse) ApiInvoker.deserialize(localVarResponse, "", StudiesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Studies (GET)
   *  Scope: PHENOTYPING. Status: ACCEPTED. Implementation target date: PAG2016. Implemented by: Germinate Used by: Flapjack, Cassavabase See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details. Get list of studies StartDate and endDate should be ISO8601 format for dates: YYYY-MM-DD &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/studies\&quot;&gt; test-server.brapi.org/brapi/v1/studies-search&lt;/a&gt;
   * @param studySearchRequest Study Search request
  */
  public void studiesSearchPost (StudySearchRequest studySearchRequest, final Response.Listener<StudiesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = studySearchRequest;


    // create path and map variables
    String path = "/studies-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((StudiesResponse) ApiInvoker.deserialize(localVarResponse,  "", StudiesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search for plates
  * Search for plates in the database.  &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/vendor/plates-search\&quot;&gt; test-server.brapi.org/brapi/v1/vendor/plates-search&lt;/a&gt;
   * @param vendorProjectDbId 
   * @param vendorPlateDbId 
   * @param clientPlateDbId 
   * @param sampleInfo 
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @return VendorPlatesResponse
  */
  public VendorPlatesResponse vendorPlatesSearchGet (String vendorProjectDbId, String vendorPlateDbId, String clientPlateDbId, Boolean sampleInfo, Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/vendor/plates-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "vendorProjectDbId", vendorProjectDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "vendorPlateDbId", vendorPlateDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "clientPlateDbId", clientPlateDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sampleInfo", sampleInfo));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (VendorPlatesResponse) ApiInvoker.deserialize(localVarResponse, "", VendorPlatesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search for plates
   * Search for plates in the database.  &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/vendor/plates-search\&quot;&gt; test-server.brapi.org/brapi/v1/vendor/plates-search&lt;/a&gt;
   * @param vendorProjectDbId    * @param vendorPlateDbId    * @param clientPlateDbId    * @param sampleInfo    * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
  */
  public void vendorPlatesSearchGet (String vendorProjectDbId, String vendorPlateDbId, String clientPlateDbId, Boolean sampleInfo, Integer pageSize, Integer page, final Response.Listener<VendorPlatesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/vendor/plates-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "vendorProjectDbId", vendorProjectDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "vendorPlateDbId", vendorPlateDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "clientPlateDbId", clientPlateDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sampleInfo", sampleInfo));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((VendorPlatesResponse) ApiInvoker.deserialize(localVarResponse,  "", VendorPlatesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search for plates
  * Search for plates in the database.  &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/vendor\&quot;&gt; test-server.brapi.org/brapi/v1/vendor/plate-search&lt;/a&gt;
   * @param body 
   * @return VendorPlatesResponse
  */
  public VendorPlatesResponse vendorPlatesSearchPost (VendorPlateSearchRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;

    // create path and map variables
    String path = "/vendor/plates-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (VendorPlatesResponse) ApiInvoker.deserialize(localVarResponse, "", VendorPlatesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search for plates
   * Search for plates in the database.  &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/vendor\&quot;&gt; test-server.brapi.org/brapi/v1/vendor/plate-search&lt;/a&gt;
   * @param body 
  */
  public void vendorPlatesSearchPost (VendorPlateSearchRequest body, final Response.Listener<VendorPlatesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;


    // create path and map variables
    String path = "/vendor/plates-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((VendorPlatesResponse) ApiInvoker.deserialize(localVarResponse,  "", VendorPlatesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
