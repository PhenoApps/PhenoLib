/**
 * BrAPI
 * The Breeding API (BrAPI) is a Standardized RESTful Web Service API Specification for communicating Plant Breeding Data. BrAPI allows for easy data sharing between databases and tools involved in plant breeding.  <strong>General Reference Documentation</strong> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/URL_Structure.md\">URL Structure</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Response_Structure.md\">Response Structure</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Date_Time_Encoding.md\">Date/Time Encoding</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Location_Encoding.md\">Location Encoding</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Error_Handling.md\">Error Handling</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Search_Services.md\">Search Services</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Asychronous_Processing.md\">Asynchronous Processing</a>
 *
 * OpenAPI spec version: 1.2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api;

import io.swagger.client.ApiInvoker;
import io.swagger.client.ApiException;
import io.swagger.client.Pair;

import io.swagger.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import java.util.*;
import io.swagger.client.model.NewObservationDbIdsResponse;
import io.swagger.client.model.NewObservationUnitDbIdsResponse;
import io.swagger.client.model.NewObservationUnitRequest;
import io.swagger.client.model.NewObservationsRequest;
import io.swagger.client.model.NewObservationsRequestWrapperDeprecated;
import io.swagger.client.model.NewObservationsTableRequest;
import io.swagger.client.model.ObservationLevelsResponse;
import io.swagger.client.model.ObservationUnitsResponse1;
import io.swagger.client.model.ObservationsResponse;
import io.swagger.client.model.PhenotypesRequest;
import io.swagger.client.model.StudyobservationsTableResponse;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class ObservationsApi {
  String basePath = "https://test-server.brapi.org/brapi/v1";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * &lt;strong&gt;Deprecated&lt;/strong&gt; List observation levels
  *  Call to retrieve the list of supported observation levels. Observation levels indicate the granularity level at which the measurements are taken. The values are used to supply the &#x60;observationLevel&#x60; parameter in the observation unit details call. 
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @return ObservationLevelsResponse
  */
  public ObservationLevelsResponse observationLevelsGet (Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/observationLevels";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObservationLevelsResponse) ApiInvoker.deserialize(localVarResponse, "", ObservationLevelsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * &lt;strong&gt;Deprecated&lt;/strong&gt; List observation levels
   *  Call to retrieve the list of supported observation levels. Observation levels indicate the granularity level at which the measurements are taken. The values are used to supply the &#x60;observationLevel&#x60; parameter in the observation unit details call. 
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
  */
  public void observationLevelsGet (Integer pageSize, Integer page, final Response.Listener<ObservationLevelsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/observationLevels".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObservationLevelsResponse) ApiInvoker.deserialize(localVarResponse,  "", ObservationLevelsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Observation Levels
  *  Call to retrieve the list of supported observation levels. Observation levels indicate the granularity level at which the measurements are taken. The values are used to supply the &#x60;observationLevel&#x60; parameter in the observation unit details call. &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/observationlevels\&quot;&gt; test-server.brapi.org/brapi/v1/observationlevels&lt;/a&gt;
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @return ObservationLevelsResponse
  */
  public ObservationLevelsResponse observationlevelsGet (Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/observationlevels";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObservationLevelsResponse) ApiInvoker.deserialize(localVarResponse, "", ObservationLevelsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Observation Levels
   *  Call to retrieve the list of supported observation levels. Observation levels indicate the granularity level at which the measurements are taken. The values are used to supply the &#x60;observationLevel&#x60; parameter in the observation unit details call. &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/observationlevels\&quot;&gt; test-server.brapi.org/brapi/v1/observationlevels&lt;/a&gt;
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
  */
  public void observationlevelsGet (Integer pageSize, Integer page, final Response.Listener<ObservationLevelsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/observationlevels".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObservationLevelsResponse) ApiInvoker.deserialize(localVarResponse,  "", ObservationLevelsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Save Observation Unit Phenotypes
  * Scope: PHENOTYPING.   Notes:  Along with the study specific phenotype saving calls (in the observationUnit and table formats), this call allows phenotypes to be saved and images to optionally be transferred as well.        Call to invoke for saving the measurements (observations) collected from field for all the observation units. Observation timestamp should be ISO 8601 https://www.w3.org/TR/NOTE-datetime In case where JSON data is zipped for faster transfer speed (as in the case of the IRRI handheld implementation), the zipped JSON file will be listed in datafiles. The zipped file contains a JSON file with the same structure as the BrAPI call. In this case a format parameter should be passed as well. Images can be optionally be uploaded using this call by providing a zipfile of all images in the datafiles, along with the actual zipfile in multi-part form data.
   * @param format In case where JSON data is zipped for faster transfer speed (as in the case of the IRRI handheld implementation), the zipped JSON file will be listed in datafiles. The zipped file contains a JSON file with the same structure as the BrAPI call.
   * @param body 
   * @return NewObservationDbIdsResponse
  */
  public NewObservationDbIdsResponse phenotypesPost (String format, PhenotypesRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;

    // create path and map variables
    String path = "/phenotypes";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NewObservationDbIdsResponse) ApiInvoker.deserialize(localVarResponse, "", NewObservationDbIdsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Save Observation Unit Phenotypes
   * Scope: PHENOTYPING.   Notes:  Along with the study specific phenotype saving calls (in the observationUnit and table formats), this call allows phenotypes to be saved and images to optionally be transferred as well.        Call to invoke for saving the measurements (observations) collected from field for all the observation units. Observation timestamp should be ISO 8601 https://www.w3.org/TR/NOTE-datetime In case where JSON data is zipped for faster transfer speed (as in the case of the IRRI handheld implementation), the zipped JSON file will be listed in datafiles. The zipped file contains a JSON file with the same structure as the BrAPI call. In this case a format parameter should be passed as well. Images can be optionally be uploaded using this call by providing a zipfile of all images in the datafiles, along with the actual zipfile in multi-part form data.
   * @param format In case where JSON data is zipped for faster transfer speed (as in the case of the IRRI handheld implementation), the zipped JSON file will be listed in datafiles. The zipped file contains a JSON file with the same structure as the BrAPI call.   * @param body 
  */
  public void phenotypesPost (String format, PhenotypesRequest body, final Response.Listener<NewObservationDbIdsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;


    // create path and map variables
    String path = "/phenotypes".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NewObservationDbIdsResponse) ApiInvoker.deserialize(localVarResponse,  "", NewObservationDbIdsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Observation Units by observation variable ids
  *  Retrieve all observations where there are measurements for the given observation variables. observationTimestamp should be ISO8601 format with timezone: YYYY-MM-DDThh:mm:ss+hhmm &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/studies\&quot;&gt; test-server.brapi.org/brapi/v1/studies/{studyDbId}/observations&lt;/a&gt;
   * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric.
   * @param observationVariableDbIds Numeric &#x60;id&#x60; of that variable (combination of trait, unit and method)
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @return ObservationsResponse
  */
  public ObservationsResponse studiesStudyDbIdObservationsGet (String studyDbId, List<String> observationVariableDbIds, Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationsGet",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationsGet"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observations".replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "observationVariableDbIds", observationVariableDbIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObservationsResponse) ApiInvoker.deserialize(localVarResponse, "", ObservationsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Observation Units by observation variable ids
   *  Retrieve all observations where there are measurements for the given observation variables. observationTimestamp should be ISO8601 format with timezone: YYYY-MM-DDThh:mm:ss+hhmm &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/studies\&quot;&gt; test-server.brapi.org/brapi/v1/studies/{studyDbId}/observations&lt;/a&gt;
   * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric.   * @param observationVariableDbIds Numeric &#x60;id&#x60; of that variable (combination of trait, unit and method)   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
  */
  public void studiesStudyDbIdObservationsGet (String studyDbId, List<String> observationVariableDbIds, Integer pageSize, Integer page, final Response.Listener<ObservationsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationsGet",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationsGet"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observations".replaceAll("\\{format\\}","json").replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "observationVariableDbIds", observationVariableDbIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObservationsResponse) ApiInvoker.deserialize(localVarResponse,  "", ObservationsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Observation Units by observation variable ids
  *  Implementation Guidelines: + If an &#x60;observationDbId&#x60; is \&quot;null\&quot; or an empty string in the request, a NEW observation should be created for the given study and observationUnit + If an &#x60;observationDbId&#x60; is populated but not found in the database, a NEW observation should be created for the given study and observationUnit AND an NEW &#x60;observationDbId&#x60; should be assigned to it. A warning should be returned to the client. + If an &#x60;observationDbId&#x60; is populated and found in the database, but the existing entry is not associated with the given study or observationUnit, a NEW observation should be created for the given study and observationUnit AND an NEW &#x60;observationDbId&#x60; should be assigned to it. A warning should be returned to the client. + If an &#x60;observationDbId&#x60; is populated and found in the database and is associated with the given study and observationUnit, then it should be updated with the new data given. &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/studies\&quot;&gt; test-server.brapi.org/brapi/v1/studies/{studyDbId}/observations&lt;/a&gt;
   * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric.
   * @param newObservations 
   * @return NewObservationDbIdsResponse
  */
  public NewObservationDbIdsResponse studiesStudyDbIdObservationsPut (String studyDbId, NewObservationsRequest newObservations) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = newObservations;
    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationsPut",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationsPut"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observations".replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "PUT", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NewObservationDbIdsResponse) ApiInvoker.deserialize(localVarResponse, "", NewObservationDbIdsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Observation Units by observation variable ids
   *  Implementation Guidelines: + If an &#x60;observationDbId&#x60; is \&quot;null\&quot; or an empty string in the request, a NEW observation should be created for the given study and observationUnit + If an &#x60;observationDbId&#x60; is populated but not found in the database, a NEW observation should be created for the given study and observationUnit AND an NEW &#x60;observationDbId&#x60; should be assigned to it. A warning should be returned to the client. + If an &#x60;observationDbId&#x60; is populated and found in the database, but the existing entry is not associated with the given study or observationUnit, a NEW observation should be created for the given study and observationUnit AND an NEW &#x60;observationDbId&#x60; should be assigned to it. A warning should be returned to the client. + If an &#x60;observationDbId&#x60; is populated and found in the database and is associated with the given study and observationUnit, then it should be updated with the new data given. &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/studies\&quot;&gt; test-server.brapi.org/brapi/v1/studies/{studyDbId}/observations&lt;/a&gt;
   * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric.   * @param newObservations 
  */
  public void studiesStudyDbIdObservationsPut (String studyDbId, NewObservationsRequest newObservations, final Response.Listener<NewObservationDbIdsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = newObservations;

    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationsPut",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationsPut"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observations".replaceAll("\\{format\\}","json").replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "PUT", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NewObservationDbIdsResponse) ApiInvoker.deserialize(localVarResponse,  "", NewObservationDbIdsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get all observation units
  *  The main API call for field data collection, to retrieve all the observation units within a study. Scope: PHENOTYPING &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/studies\&quot;&gt; test-server.brapi.org/brapi/v1/studies/{studyDbId}/observationunits&lt;/a&gt;
   * @param studyDbId The study these observation units are related to.
   * @param observationLevel The granularity level of observation units. Either &#x60;plotNumber&#x60; or &#x60;plantNumber&#x60; fields will be relavant depending on whether granularity is plot or plant respectively.
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @return ObservationUnitsResponse1
  */
  public ObservationUnitsResponse1 studiesStudyDbIdObservationunitsGet (String studyDbId, String observationLevel, Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsGet",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsGet"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observationunits".replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationLevel", observationLevel));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObservationUnitsResponse1) ApiInvoker.deserialize(localVarResponse, "", ObservationUnitsResponse1.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get all observation units
   *  The main API call for field data collection, to retrieve all the observation units within a study. Scope: PHENOTYPING &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/studies\&quot;&gt; test-server.brapi.org/brapi/v1/studies/{studyDbId}/observationunits&lt;/a&gt;
   * @param studyDbId The study these observation units are related to.   * @param observationLevel The granularity level of observation units. Either &#x60;plotNumber&#x60; or &#x60;plantNumber&#x60; fields will be relavant depending on whether granularity is plot or plant respectively.   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
  */
  public void studiesStudyDbIdObservationunitsGet (String studyDbId, String observationLevel, Integer pageSize, Integer page, final Response.Listener<ObservationUnitsResponse1> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsGet",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsGet"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observationunits".replaceAll("\\{format\\}","json").replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "observationLevel", observationLevel));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObservationUnitsResponse1) ApiInvoker.deserialize(localVarResponse,  "", ObservationUnitsResponse1.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * &lt;strong&gt;Deprecated&lt;/strong&gt; Save Observation Unit Phenotypes
  * This call has been deprecated in V1.1. Use instead: \&quot;PUT /studies/{studyDbId}/observationunits\&quot; and \&quot;PUT /studies/{studyDbId}/observationunits/zip\&quot;
   * @param studyDbId The study these observation units are related to.
   * @param format (default is JSON, but can be zip) In case where JSON data is zipped for faster transfer speed (as in the case of the IRRI handheld implementation), the zipped JSON file will be listed in datafiles. The zipped file contains a JSON file with the same structure as the BrAPI call.
   * @param body 
   * @return void
  */
  public void studiesStudyDbIdObservationunitsPost (String studyDbId, String format, NewObservationsRequestWrapperDeprecated body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsPost",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsPost"));
    }
    // verify the required parameter 'format' is set
    if (format == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'format' when calling studiesStudyDbIdObservationunitsPost",
        new ApiException(400, "Missing the required parameter 'format' when calling studiesStudyDbIdObservationunitsPost"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observationunits".replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * &lt;strong&gt;Deprecated&lt;/strong&gt; Save Observation Unit Phenotypes
   * This call has been deprecated in V1.1. Use instead: \&quot;PUT /studies/{studyDbId}/observationunits\&quot; and \&quot;PUT /studies/{studyDbId}/observationunits/zip\&quot;
   * @param studyDbId The study these observation units are related to.   * @param format (default is JSON, but can be zip) In case where JSON data is zipped for faster transfer speed (as in the case of the IRRI handheld implementation), the zipped JSON file will be listed in datafiles. The zipped file contains a JSON file with the same structure as the BrAPI call.   * @param body 
  */
  public void studiesStudyDbIdObservationunitsPost (String studyDbId, String format, NewObservationsRequestWrapperDeprecated body, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsPost",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsPost"));
    }
    // verify the required parameter 'format' is set
    if (format == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'format' when calling studiesStudyDbIdObservationunitsPost",
        new ApiException(400, "Missing the required parameter 'format' when calling studiesStudyDbIdObservationunitsPost"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observationunits".replaceAll("\\{format\\}","json").replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Save Observation Unit Phenotypes
  * Use this call for uploading new Observations as JSON to a system.  Note: If &#39;observationUnitDbId&#39; or &#39;observationDbId&#39; is populated, they should be considered updates to existing records. If an existing record of that DbId is not found, the document should be treated as new records and assigned new DbIds. If &#39;observationUnitDbId&#39; or &#39;observationDbId&#39; is un-populated (empty string or null) the document should be treated as new records and assigned new DbIds.
   * @param studyDbId The study these observation units are related to.
   * @param newObservationUnitRequest 
   * @return NewObservationUnitDbIdsResponse
  */
  public NewObservationUnitDbIdsResponse studiesStudyDbIdObservationunitsPut (String studyDbId, List<NewObservationUnitRequest> newObservationUnitRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = newObservationUnitRequest;
    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsPut",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsPut"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observationunits".replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "PUT", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NewObservationUnitDbIdsResponse) ApiInvoker.deserialize(localVarResponse, "", NewObservationUnitDbIdsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Save Observation Unit Phenotypes
   * Use this call for uploading new Observations as JSON to a system.  Note: If &#39;observationUnitDbId&#39; or &#39;observationDbId&#39; is populated, they should be considered updates to existing records. If an existing record of that DbId is not found, the document should be treated as new records and assigned new DbIds. If &#39;observationUnitDbId&#39; or &#39;observationDbId&#39; is un-populated (empty string or null) the document should be treated as new records and assigned new DbIds.
   * @param studyDbId The study these observation units are related to.   * @param newObservationUnitRequest 
  */
  public void studiesStudyDbIdObservationunitsPut (String studyDbId, List<NewObservationUnitRequest> newObservationUnitRequest, final Response.Listener<NewObservationUnitDbIdsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = newObservationUnitRequest;

    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsPut",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsPut"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observationunits".replaceAll("\\{format\\}","json").replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "PUT", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NewObservationUnitDbIdsResponse) ApiInvoker.deserialize(localVarResponse,  "", NewObservationUnitDbIdsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Use this call for uploading new Observations as a Batched Zip File to a system.
  * Note: If &#39;observationUnitDbId&#39; or &#39;observationDbId&#39; is populated, they should be considered updates to existing records. If an existing record of that DbId is not found, the document should be treated as new records and assigned new DbIds. If &#39;observationUnitDbId&#39; or &#39;observationDbId&#39; is un-populated (empty string or null) the document should be treated as new records and assigned new DbIds.
   * @param studyDbId The study these observation units are related to.
   * @param zipRequest 
   * @return NewObservationUnitDbIdsResponse
  */
  public NewObservationUnitDbIdsResponse studiesStudyDbIdObservationunitsZipPost (String studyDbId, byte[] zipRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = zipRequest;
    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsZipPost",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsZipPost"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observationunits/zip".replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/zip"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NewObservationUnitDbIdsResponse) ApiInvoker.deserialize(localVarResponse, "", NewObservationUnitDbIdsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Use this call for uploading new Observations as a Batched Zip File to a system.
   * Note: If &#39;observationUnitDbId&#39; or &#39;observationDbId&#39; is populated, they should be considered updates to existing records. If an existing record of that DbId is not found, the document should be treated as new records and assigned new DbIds. If &#39;observationUnitDbId&#39; or &#39;observationDbId&#39; is un-populated (empty string or null) the document should be treated as new records and assigned new DbIds.
   * @param studyDbId The study these observation units are related to.   * @param zipRequest 
  */
  public void studiesStudyDbIdObservationunitsZipPost (String studyDbId, byte[] zipRequest, final Response.Listener<NewObservationUnitDbIdsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = zipRequest;

    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsZipPost",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsZipPost"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observationunits/zip".replaceAll("\\{format\\}","json").replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/zip"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NewObservationUnitDbIdsResponse) ApiInvoker.deserialize(localVarResponse,  "", NewObservationUnitDbIdsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Retrieve study Observation Units as table
  *  Scope: PHENOTYPING. Status: ACCEPTED. Implemented in Cassavabase, HIDAP and Germinate. Notes: Implementation target date: after PAG2016 Retrieve the details of the study required for field data collection. Includes actual trait data. &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/studies\&quot;&gt; test-server.brapi.org/brapi/v1/studies/{studyDbId}/table&lt;/a&gt;
   * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric.
   * @param format The format parameter will cause the data to be dumped to a file in the specified format. Currently, tsv and csv are supported.
   * @return StudyobservationsTableResponse
  */
  public StudyobservationsTableResponse studiesStudyDbIdTableGet (String studyDbId, String format) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdTableGet",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdTableGet"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/table".replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (StudyobservationsTableResponse) ApiInvoker.deserialize(localVarResponse, "", StudyobservationsTableResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Retrieve study Observation Units as table
   *  Scope: PHENOTYPING. Status: ACCEPTED. Implemented in Cassavabase, HIDAP and Germinate. Notes: Implementation target date: after PAG2016 Retrieve the details of the study required for field data collection. Includes actual trait data. &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/studies\&quot;&gt; test-server.brapi.org/brapi/v1/studies/{studyDbId}/table&lt;/a&gt;
   * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric.   * @param format The format parameter will cause the data to be dumped to a file in the specified format. Currently, tsv and csv are supported.
  */
  public void studiesStudyDbIdTableGet (String studyDbId, String format, final Response.Listener<StudyobservationsTableResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdTableGet",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdTableGet"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/table".replaceAll("\\{format\\}","json").replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((StudyobservationsTableResponse) ApiInvoker.deserialize(localVarResponse,  "", StudyobservationsTableResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Save study Observation Units as table
  *  This call can be used to create new observations in bulk. Note: If you need to update any existing observation, please use &#x60;PUT /studies/{studyDbId}/observations&#x60;. This call should only be used to create NEW observations. Implementation Guidelines: + All observations submitted through this call should create NEW observation records in the database under the given observation unit. + Each \&quot;observationUnitDbId\&quot; listed should already exist in the database. If the server can not find a given \&quot;observationUnitDbId\&quot;, it should report an error. (see Error Handling) + The response of this call should be the set of \&quot;observationDbIds\&quot; created from this call, along with the associated \&quot;observationUnitDbId\&quot; and \&quot;observationVariableDbId\&quot; that each observation is associated with. Images can optionally be saved using this call by providing a zipped file of all images in the datafiles. The physical zipped file should be transferred as well in the mulit-part form data. Scope: PHENOTYPING 
   * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric.
   * @param newObservationsTableRequest 
   * @return NewObservationDbIdsResponse
  */
  public NewObservationDbIdsResponse studiesStudyDbIdTablePost (String studyDbId, NewObservationsTableRequest newObservationsTableRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = newObservationsTableRequest;
    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdTablePost",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdTablePost"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/table".replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NewObservationDbIdsResponse) ApiInvoker.deserialize(localVarResponse, "", NewObservationDbIdsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Save study Observation Units as table
   *  This call can be used to create new observations in bulk. Note: If you need to update any existing observation, please use &#x60;PUT /studies/{studyDbId}/observations&#x60;. This call should only be used to create NEW observations. Implementation Guidelines: + All observations submitted through this call should create NEW observation records in the database under the given observation unit. + Each \&quot;observationUnitDbId\&quot; listed should already exist in the database. If the server can not find a given \&quot;observationUnitDbId\&quot;, it should report an error. (see Error Handling) + The response of this call should be the set of \&quot;observationDbIds\&quot; created from this call, along with the associated \&quot;observationUnitDbId\&quot; and \&quot;observationVariableDbId\&quot; that each observation is associated with. Images can optionally be saved using this call by providing a zipped file of all images in the datafiles. The physical zipped file should be transferred as well in the mulit-part form data. Scope: PHENOTYPING 
   * @param studyDbId Identifier of the study. Usually a number, could be alphanumeric.   * @param newObservationsTableRequest 
  */
  public void studiesStudyDbIdTablePost (String studyDbId, NewObservationsTableRequest newObservationsTableRequest, final Response.Listener<NewObservationDbIdsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = newObservationsTableRequest;

    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdTablePost",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdTablePost"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/table".replaceAll("\\{format\\}","json").replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NewObservationDbIdsResponse) ApiInvoker.deserialize(localVarResponse,  "", NewObservationDbIdsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
