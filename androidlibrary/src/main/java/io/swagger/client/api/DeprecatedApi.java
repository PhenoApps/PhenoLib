/**
 * BrAPI
 * The Breeding API (BrAPI) is a Standardized RESTful Web Service API Specification for communicating Plant Breeding Data. BrAPI allows for easy data sharing between databases and tools involved in plant breeding.  <strong>General Reference Documentation</strong> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/URL_Structure.md\">URL Structure</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Response_Structure.md\">Response Structure</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Date_Time_Encoding.md\">Date/Time Encoding</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Location_Encoding.md\">Location Encoding</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Error_Handling.md\">Error Handling</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Search_Services.md\">Search Services</a> <a href=\"https://github.com/plantbreeding/API/blob/master/Specification/GeneralInfo/Asychronous_Processing.md\">Asynchronous Processing</a>
 *
 * OpenAPI spec version: 1.2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api;

import io.swagger.client.ApiInvoker;
import io.swagger.client.ApiException;
import io.swagger.client.Pair;

import io.swagger.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import io.swagger.client.model.AlleleMatrixSearchRequest;
import io.swagger.client.model.AlleleMatrixValuesResponse;
import io.swagger.client.model.CommonCropNamesResponse;
import io.swagger.client.model.MarkersResponse2;
import io.swagger.client.model.NewObservationsRequestWrapperDeprecated;
import io.swagger.client.model.ObservationLevelsResponse;
import io.swagger.client.model.StudyObservationVariablesResponse;
import io.swagger.client.model.StudyTypesResponse;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class DeprecatedApi {
  String basePath = "https://test-server.brapi.org/brapi/v1";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Scores through GET
  * Status: ACCEPTED.  Implemented by: Germinate (POST only), Cassavabase  Used by: Flapjack (POST only)  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  This uses a more efficient data structure and pagination for large number of markers.  See Search Services for additional implementation details. &lt;/br&gt; This uses a more efficient data structure and pagination for large number of markers.  &lt;/br&gt; Use GET when parameter size is less than 2K bytes. This method may support asynchronous processing.
   * @param markerprofileDbId The markerprofile db ids. Not Required if &#39;markerDbId&#39; or &#39;matrixDbId&#39; is present.
   * @param markerDbId ids of the markers. if none are specified, results are returned for all markers in the database. Not Required if &#39;markerprofileDbId&#39; or &#39;matrixDbId&#39; is present.
   * @param matrixDbId 
   * @param format format for the datafile to be downloaded. tsv and csv currently supported; flapjack may be supported.
   * @param expandHomozygotes Should homozygotes NOT be collapsed into a single occurrence?
   * @param unknownString The string to use as a representation for missing data or the reserved word \&quot;empty_string\&quot;.
   * @param sepPhased The string to use as a separator for phased allele calls or the reserved word \&quot;empty_string\&quot;.
   * @param sepUnphased The string to use as a separator for unphased allele calls or the reserved word \&quot;empty_string\&quot;.
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @return AlleleMatrixValuesResponse
  */
  public AlleleMatrixValuesResponse allelematrixSearchGet (List<String> markerprofileDbId, List<String> markerDbId, List<String> matrixDbId, String format, Boolean expandHomozygotes, String unknownString, String sepPhased, String sepUnphased, Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/allelematrix-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "markerprofileDbId", markerprofileDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "markerDbId", markerDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "matrixDbId", matrixDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "expandHomozygotes", expandHomozygotes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "unknownString", unknownString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepPhased", sepPhased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepUnphased", sepUnphased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AlleleMatrixValuesResponse) ApiInvoker.deserialize(localVarResponse, "", AlleleMatrixValuesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Scores through GET
   * Status: ACCEPTED.  Implemented by: Germinate (POST only), Cassavabase  Used by: Flapjack (POST only)  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  This uses a more efficient data structure and pagination for large number of markers.  See Search Services for additional implementation details. &lt;/br&gt; This uses a more efficient data structure and pagination for large number of markers.  &lt;/br&gt; Use GET when parameter size is less than 2K bytes. This method may support asynchronous processing.
   * @param markerprofileDbId The markerprofile db ids. Not Required if &#39;markerDbId&#39; or &#39;matrixDbId&#39; is present.   * @param markerDbId ids of the markers. if none are specified, results are returned for all markers in the database. Not Required if &#39;markerprofileDbId&#39; or &#39;matrixDbId&#39; is present.   * @param matrixDbId    * @param format format for the datafile to be downloaded. tsv and csv currently supported; flapjack may be supported.   * @param expandHomozygotes Should homozygotes NOT be collapsed into a single occurrence?   * @param unknownString The string to use as a representation for missing data or the reserved word \&quot;empty_string\&quot;.   * @param sepPhased The string to use as a separator for phased allele calls or the reserved word \&quot;empty_string\&quot;.   * @param sepUnphased The string to use as a separator for unphased allele calls or the reserved word \&quot;empty_string\&quot;.   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
  */
  public void allelematrixSearchGet (List<String> markerprofileDbId, List<String> markerDbId, List<String> matrixDbId, String format, Boolean expandHomozygotes, String unknownString, String sepPhased, String sepUnphased, Integer pageSize, Integer page, final Response.Listener<AlleleMatrixValuesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/allelematrix-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "markerprofileDbId", markerprofileDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "markerDbId", markerDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "matrixDbId", matrixDbId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "expandHomozygotes", expandHomozygotes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "unknownString", unknownString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepPhased", sepPhased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sepUnphased", sepUnphased));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AlleleMatrixValuesResponse) ApiInvoker.deserialize(localVarResponse,  "", AlleleMatrixValuesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Scores through POST
  * Status: ACCEPTED.  Implemented by: Germinate (POST only), Cassavabase  Used by: Flapjack (POST only)  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  This uses a more efficient data structure and pagination for large number of markers.  Use POST when parameter size is greater than 2K bytes.  - If no format is specified, this call returns the data in JSON form.  - If a format (other than JSON) is specified and the server supports this format, it will return the link to the exported data file in the \&quot;datafiles\&quot; field of the \&quot;metadata\&quot;.  - If more than one format is requested at a time, the server will throw a \&quot;501 Not Implemented\&quot; error.  The format of the tsv response can be found on GitHub (https://github.com/plantbreeding/Documentation/wiki/BrAPI-TSV-Expected-Formats)
   * @param markerprofileDbId The markerprofile db ids. Not Required if &#39;markerDbId&#39; or &#39;matrixDbId&#39; is present.
   * @return AlleleMatrixValuesResponse
  */
  public AlleleMatrixValuesResponse allelematrixSearchPost (AlleleMatrixSearchRequest markerprofileDbId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = markerprofileDbId;
    // verify the required parameter 'markerprofileDbId' is set
    if (markerprofileDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'markerprofileDbId' when calling allelematrixSearchPost",
        new ApiException(400, "Missing the required parameter 'markerprofileDbId' when calling allelematrixSearchPost"));
    }

    // create path and map variables
    String path = "/allelematrix-search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AlleleMatrixValuesResponse) ApiInvoker.deserialize(localVarResponse, "", AlleleMatrixValuesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Scores through POST
   * Status: ACCEPTED.  Implemented by: Germinate (POST only), Cassavabase  Used by: Flapjack (POST only)  See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details.  This uses a more efficient data structure and pagination for large number of markers.  Use POST when parameter size is greater than 2K bytes.  - If no format is specified, this call returns the data in JSON form.  - If a format (other than JSON) is specified and the server supports this format, it will return the link to the exported data file in the \&quot;datafiles\&quot; field of the \&quot;metadata\&quot;.  - If more than one format is requested at a time, the server will throw a \&quot;501 Not Implemented\&quot; error.  The format of the tsv response can be found on GitHub (https://github.com/plantbreeding/Documentation/wiki/BrAPI-TSV-Expected-Formats)
   * @param markerprofileDbId The markerprofile db ids. Not Required if &#39;markerDbId&#39; or &#39;matrixDbId&#39; is present.
  */
  public void allelematrixSearchPost (AlleleMatrixSearchRequest markerprofileDbId, final Response.Listener<AlleleMatrixValuesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = markerprofileDbId;

    // verify the required parameter 'markerprofileDbId' is set
    if (markerprofileDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'markerprofileDbId' when calling allelematrixSearchPost",
        new ApiException(400, "Missing the required parameter 'markerprofileDbId' when calling allelematrixSearchPost"));
    }

    // create path and map variables
    String path = "/allelematrix-search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AlleleMatrixValuesResponse) ApiInvoker.deserialize(localVarResponse,  "", AlleleMatrixValuesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * List supported crops
  * For multi crop systems this is a useful call to list all the supported crops.  &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/crops\&quot;&gt; test-server.brapi.org/brapi/v1/crops&lt;/a&gt;
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @return CommonCropNamesResponse
  */
  public CommonCropNamesResponse cropsGet (Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/crops";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (CommonCropNamesResponse) ApiInvoker.deserialize(localVarResponse, "", CommonCropNamesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * List supported crops
   * For multi crop systems this is a useful call to list all the supported crops.  &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/crops\&quot;&gt; test-server.brapi.org/brapi/v1/crops&lt;/a&gt;
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
  */
  public void cropsGet (Integer pageSize, Integer page, final Response.Listener<CommonCropNamesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/crops".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((CommonCropNamesResponse) ApiInvoker.deserialize(localVarResponse,  "", CommonCropNamesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Markers Search (/markers)
  *  Scope: CORE.  Status: ACCEPTED. Implemented by: Germinate See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details. Other service requests use the servers internal &#x60;markerDbId&#x60;. This service returns marker records that provide the markerDbId. For the requested name or synonym, returns an array (possibly empty) of marker records that match the search criteria. - If there is none, an empty array is returned. - If there is one or more than one match, returns an array of all marker records that match the search criteria. 
   * @param name The name or synonym.
   * @param matchMethod Possible values are &#39;case_insensitive&#39;, &#39;exact&#39; (case sensitive), &#39;wildcard&#39; (which is case insensitive). Wildcard uses both &#39;*&#39; and &#39;%&#39; for any number of characters and &#39;?&#39; for one character matching. Default is exact.
   * @param include Whether to include synonyms in the output.
   * @param type The type of the marker.
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @return MarkersResponse2
  */
  public MarkersResponse2 markersGet (String name, String matchMethod, String include, String type, Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/markers";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "matchMethod", matchMethod));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "include", include));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "type", type));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (MarkersResponse2) ApiInvoker.deserialize(localVarResponse, "", MarkersResponse2.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Markers Search (/markers)
   *  Scope: CORE.  Status: ACCEPTED. Implemented by: Germinate See &lt;a href&#x3D;\&quot;#introduction/search-services\&quot;&gt;Search Services&lt;/a&gt; for additional implementation details. Other service requests use the servers internal &#x60;markerDbId&#x60;. This service returns marker records that provide the markerDbId. For the requested name or synonym, returns an array (possibly empty) of marker records that match the search criteria. - If there is none, an empty array is returned. - If there is one or more than one match, returns an array of all marker records that match the search criteria. 
   * @param name The name or synonym.   * @param matchMethod Possible values are &#39;case_insensitive&#39;, &#39;exact&#39; (case sensitive), &#39;wildcard&#39; (which is case insensitive). Wildcard uses both &#39;*&#39; and &#39;%&#39; for any number of characters and &#39;?&#39; for one character matching. Default is exact.   * @param include Whether to include synonyms in the output.   * @param type The type of the marker.   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
  */
  public void markersGet (String name, String matchMethod, String include, String type, Integer pageSize, Integer page, final Response.Listener<MarkersResponse2> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/markers".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "matchMethod", matchMethod));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "include", include));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "type", type));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((MarkersResponse2) ApiInvoker.deserialize(localVarResponse,  "", MarkersResponse2.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * &lt;strong&gt;Deprecated&lt;/strong&gt; List observation levels
  *  Call to retrieve the list of supported observation levels. Observation levels indicate the granularity level at which the measurements are taken. The values are used to supply the &#x60;observationLevel&#x60; parameter in the observation unit details call. 
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @return ObservationLevelsResponse
  */
  public ObservationLevelsResponse observationLevelsGet (Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/observationLevels";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObservationLevelsResponse) ApiInvoker.deserialize(localVarResponse, "", ObservationLevelsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * &lt;strong&gt;Deprecated&lt;/strong&gt; List observation levels
   *  Call to retrieve the list of supported observation levels. Observation levels indicate the granularity level at which the measurements are taken. The values are used to supply the &#x60;observationLevel&#x60; parameter in the observation unit details call. 
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
  */
  public void observationLevelsGet (Integer pageSize, Integer page, final Response.Listener<ObservationLevelsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/observationLevels".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObservationLevelsResponse) ApiInvoker.deserialize(localVarResponse,  "", ObservationLevelsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * &lt;strong&gt;Deprecated&lt;/strong&gt; Retrieve study observation variables
  *   &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/studies\&quot;&gt; test-server.brapi.org/brapi/v1/studies/{studyDbId}/observationVariables&lt;/a&gt;
   * @param studyDbId string database unique identifier
   * @return StudyObservationVariablesResponse
  */
  public StudyObservationVariablesResponse studiesStudyDbIdObservationVariablesGet (String studyDbId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationVariablesGet",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationVariablesGet"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observationVariables".replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (StudyObservationVariablesResponse) ApiInvoker.deserialize(localVarResponse, "", StudyObservationVariablesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * &lt;strong&gt;Deprecated&lt;/strong&gt; Retrieve study observation variables
   *   &lt;a href&#x3D;\&quot;https://test-server.brapi.org/brapi/v1/studies\&quot;&gt; test-server.brapi.org/brapi/v1/studies/{studyDbId}/observationVariables&lt;/a&gt;
   * @param studyDbId string database unique identifier
  */
  public void studiesStudyDbIdObservationVariablesGet (String studyDbId, final Response.Listener<StudyObservationVariablesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationVariablesGet",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationVariablesGet"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observationVariables".replaceAll("\\{format\\}","json").replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((StudyObservationVariablesResponse) ApiInvoker.deserialize(localVarResponse,  "", StudyObservationVariablesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * &lt;strong&gt;Deprecated&lt;/strong&gt; Save Observation Unit Phenotypes
  * This call has been deprecated in V1.1. Use instead: \&quot;PUT /studies/{studyDbId}/observationunits\&quot; and \&quot;PUT /studies/{studyDbId}/observationunits/zip\&quot;
   * @param studyDbId The study these observation units are related to.
   * @param format (default is JSON, but can be zip) In case where JSON data is zipped for faster transfer speed (as in the case of the IRRI handheld implementation), the zipped JSON file will be listed in datafiles. The zipped file contains a JSON file with the same structure as the BrAPI call.
   * @param body 
   * @return void
  */
  public void studiesStudyDbIdObservationunitsPost (String studyDbId, String format, NewObservationsRequestWrapperDeprecated body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsPost",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsPost"));
    }
    // verify the required parameter 'format' is set
    if (format == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'format' when calling studiesStudyDbIdObservationunitsPost",
        new ApiException(400, "Missing the required parameter 'format' when calling studiesStudyDbIdObservationunitsPost"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observationunits".replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * &lt;strong&gt;Deprecated&lt;/strong&gt; Save Observation Unit Phenotypes
   * This call has been deprecated in V1.1. Use instead: \&quot;PUT /studies/{studyDbId}/observationunits\&quot; and \&quot;PUT /studies/{studyDbId}/observationunits/zip\&quot;
   * @param studyDbId The study these observation units are related to.   * @param format (default is JSON, but can be zip) In case where JSON data is zipped for faster transfer speed (as in the case of the IRRI handheld implementation), the zipped JSON file will be listed in datafiles. The zipped file contains a JSON file with the same structure as the BrAPI call.   * @param body 
  */
  public void studiesStudyDbIdObservationunitsPost (String studyDbId, String format, NewObservationsRequestWrapperDeprecated body, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'studyDbId' is set
    if (studyDbId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsPost",
        new ApiException(400, "Missing the required parameter 'studyDbId' when calling studiesStudyDbIdObservationunitsPost"));
    }
    // verify the required parameter 'format' is set
    if (format == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'format' when calling studiesStudyDbIdObservationunitsPost",
        new ApiException(400, "Missing the required parameter 'format' when calling studiesStudyDbIdObservationunitsPost"));
    }

    // create path and map variables
    String path = "/studies/{studyDbId}/observationunits".replaceAll("\\{format\\}","json").replaceAll("\\{" + "studyDbId" + "\\}", apiInvoker.escapeString(studyDbId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "format", format));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * &lt;strong&gt;Deprecated&lt;/strong&gt; List study types
  *  Call to retrieve the list of study types. Scope: PHENOTYPING. Implementation target date: PAG2016 
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.
   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
   * @return StudyTypesResponse
  */
  public StudyTypesResponse studyTypesGet (Integer pageSize, Integer page) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/studyTypes";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (StudyTypesResponse) ApiInvoker.deserialize(localVarResponse, "", StudyTypesResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * &lt;strong&gt;Deprecated&lt;/strong&gt; List study types
   *  Call to retrieve the list of study types. Scope: PHENOTYPING. Implementation target date: PAG2016 
   * @param pageSize The size of the pages to be returned. Default is &#x60;1000&#x60;.   * @param page Which result page is requested. The page indexing starts at 0 (the first page is &#39;page&#39;&#x3D; 0). Default is &#x60;0&#x60;.
  */
  public void studyTypesGet (Integer pageSize, Integer page, final Response.Listener<StudyTypesResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/studyTypes".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "pageSize", pageSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((StudyTypesResponse) ApiInvoker.deserialize(localVarResponse,  "", StudyTypesResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Logout
  * 
   * @return void
  */
  public void tokenDelete () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/token";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Logout
   * 

  */
  public void tokenDelete (final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/token".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Login
  * 
   * @return void
  */
  public void tokenPost () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/token";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Login
   * 

  */
  public void tokenPost (final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/token".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
